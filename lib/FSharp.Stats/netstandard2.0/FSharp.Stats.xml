<?xml version="1.0" encoding="utf-8"?>
<doc>
<assembly><name>FSharp.Stats</name></assembly>
<members>
<member name="T:FSharp.Stats.complex">
<summary>
Complex number            
</summary>
</member>
<member name="T:FSharp.Stats.Complex">
<summary>
Complex number in cartesian form
</summary>
</member>
<member name="P:FSharp.Stats.Vector`1.Length">
<summary>
Length of vector
</summary>
</member>
<member name="T:FSharp.Stats.OpsData`1">
<summary>
 The value stored for the dictionary of numeric operations. If none is present then this indicates
 no operations are known for this type.
</summary>
</member>
<member name="T:FSharp.Stats.LinearAlgebraLAPACK">
<summary>
 Internal provider of Lapack functionality, not for direct user usage.
</summary>
</member>
<member name="M:FSharp.Stats.LinearAlgebraMKL.FSharp-Stats-Algebra-ILinearAlgebra-dgesdd_(FSharp.Stats.Matrix{System.Double})">
<summary>
Singular Value Decomposition Divide- Conquer
</summary>
</member>
<member name="M:FSharp.Stats.LinearAlgebraMKL.FSharp-Stats-Algebra-ILinearAlgebra-dgemm_(FSharp.Stats.Matrix{System.Double},FSharp.Stats.Matrix{System.Double})">
<summary>
Matrix-Matrix Multiplication
</summary>
</member>
<member name="T:FSharp.Stats.LinearAlgebraMKL">
<summary>
 Internal provider of MKL functionality, not for direct user usage.
</summary>
</member>
<member name="M:FSharp.Stats.Ops.signum(System.Double,System.Double)">
<summary>
 Signum function, assigns a positive sign to a with respect to the signing of b. 
</summary>
</member>
<member name="M:FSharp.Stats.Ops.round(System.Int32,System.Double)">
<summary>
 Rounds a double-precision floating-point value to a specified number of fractional digits.  
</summary>
</member>
<member name="M:FSharp.Stats.Ops.arsinh(System.Double)">

</member>
<member name="M:FSharp.Stats.Ops.square``2(``0)">
<summary>
 Returns x squared (x^2)
</summary>
</member>
<member name="M:FSharp.Stats.Ops.revLog2(System.Double)">
<summary>
 Returns the reverted log2 (2^x)
</summary>
</member>
<member name="M:FSharp.Stats.Ops.isInf(System.Double)">
<summary>
 Returs true if x is Float infinity
</summary>
</member>
<member name="M:FSharp.Stats.Ops.isNan(System.Double)">
<summary>
 Returs true if x is Float NaN
</summary>
</member>
<member name="M:FSharp.Stats.Ops.log10(System.Double)">
<summary>
 Returns the logarithm for x in base 10.
</summary>
</member>
<member name="M:FSharp.Stats.Ops.log2(System.Double)">
<summary>
 Returns the logarithm for x in base 2.
</summary>
</member>
<member name="P:FSharp.Stats.Ops.NaN">
<summary>
 Float NaN.
</summary>
</member>
<member name="P:FSharp.Stats.Ops.inf">
<summary>
 Float infinity.
</summary>
</member>
<member name="P:FSharp.Stats.Ops.sqrt2pi">
<summary>
 The constant pi = 3.141596...
</summary>
</member>
<member name="P:FSharp.Stats.Ops.pi">
<summary>
 The constant pi = 3.141596...
</summary>
</member>
<member name="T:FSharp.Stats.Ops">
<summary>
 Operations module (automatically opened)
</summary>
</member>
<member name="M:FSharp.Stats.Random.RandBasic.#ctor(System.Int32)">
<summary>
 If n is negative, the random number generator seed is based on system time, if it is zero or positive it will
 use n as the seed.
</summary>
</member>
<member name="M:FSharp.Stats.Random.RandBasic.#ctor">
<summary>
 Constructs the default random number generator with seed 17.
</summary>
</member>
<member name="T:FSharp.Stats.Random.RandBasic">
<summary>
 A standard implementation of a uniform random source using System.Random()
</summary>
</member>
<member name="T:FSharp.Stats.Random.IRandom">
<summary>
 Interface that every uniform random number generator must implement.
</summary>
</member>
<member name="M:FSharp.Stats.Random.GetSampleGenerator">
<summary>
 Returns the random number generator used for sampling.
</summary>
</member>
<member name="M:FSharp.Stats.Random.SetSampleGenerator(FSharp.Stats.Random.IRandom)">
<summary>
 Sets the random number generator used for sampling.
</summary>
</member>
<member name="P:FSharp.Stats.Random.rndgen">
<summary>
 The uniform random source used for sampling functions.
</summary>
</member>
<member name="T:FSharp.Stats.Random">
<summary>
 Uniform random number generators
</summary>
</member>
<member name="P:FSharp.Stats.ServiceLocator.ServiceProvider`1.Providers(FSharp.Stats.ServiceLocator.Provider{`0}[])">
<summary>
 Service Providers
</summary>
</member>
<member name="P:FSharp.Stats.ServiceLocator.ServiceProvider`1.Providers">
<summary>
 Service Providers
</summary>
</member>
<member name="M:FSharp.Stats.ServiceLocator.ServiceProvider`1.Stop">
<summary>
 Disable the service.
</summary>
</member>
<member name="M:FSharp.Stats.ServiceLocator.ServiceProvider`1.StartWith(FSharp.Stats.ServiceLocator.Provider{`0})">
<summary>
 Use the LAPACK service from the given provider.
 If the supporting DLLs are not available, this may fail (now or later).
</summary>
</member>
<member name="M:FSharp.Stats.ServiceLocator.ServiceProvider`1.Start">
<summary>
 Start the service with the first provider that looks loadable.     
</summary>
</member>
<member name="T:FSharp.Stats.ServiceLocator.Provider`1">
<summary>
 Generic provider with unmanaged DLL dependencies.
</summary>
</member>
<member name="M:FSharp.Stats.ServiceLocator.initSearchPaths">
<summary>
 The DLLs search procedure for those DLLs
</summary>
</member>
<member name="T:FSharp.Stats.Intervals.Interval`1">
<summary>
 Closed interval [Start,End]
</summary>
</member>
<member name="M:FSharp.Stats.Intervals.liesInInterval``1(``0,FSharp.Stats.Intervals.Interval{``0})">
<summary>
   Does the given value lie in the interval or not.
</summary>
</member>
<member name="M:FSharp.Stats.Intervals.getValueAt``2(System.Double,FSharp.Stats.Intervals.Interval{``0})">
<summary>
 Get the value at a given percentage within (0.0 - 1.0) or outside (&lt; 0.0, &gt; 1.0) of the interval. Rounding to nearest neighbour occurs when needed.
</summary>
</member>
<member name="M:FSharp.Stats.Intervals.intersect``1(FSharp.Stats.Intervals.Interval{``0},FSharp.Stats.Intervals.Interval{``0})">
<summary>
 Returns the intersection of this interval with another.
</summary>
</member>
<member name="M:FSharp.Stats.Intervals.isIntersection``1(FSharp.Stats.Intervals.Interval{``0},FSharp.Stats.Intervals.Interval{``0})">
<summary>
 Checking for intersection of both intervals
</summary>
</member>
<member name="M:FSharp.Stats.Intervals.subtract(FSharp.Stats.Intervals.Interval{System.Int32},FSharp.Stats.Intervals.Interval{System.Int32})">
<summary>
 Subtract a given interval from the other interval.
</summary>
</member>
<member name="M:FSharp.Stats.Intervals.add(FSharp.Stats.Intervals.Interval{System.Int32},FSharp.Stats.Intervals.Interval{System.Int32})">
<summary>
 Add two given intervals.
</summary>
</member>
<member name="M:FSharp.Stats.Intervals.toString``1(FSharp.Stats.Intervals.Interval{``0})">
<summary>
 Returns the interval as a string
</summary>
</member>
<member name="M:FSharp.Stats.Intervals.trySize``2(FSharp.Stats.Intervals.Interval{``0})">
<summary>
 Returns the size of an closed interval
</summary>
</member>
<member name="M:FSharp.Stats.Intervals.getEnd``1(FSharp.Stats.Intervals.Interval{``0})">
<summary>
 Returns max/end value of Interval [min,max]
</summary>
</member>
<member name="M:FSharp.Stats.Intervals.getStart``1(FSharp.Stats.Intervals.Interval{``0})">
<summary>
 Returns min/start value of Interval [min,max]
</summary>
</member>
<member name="M:FSharp.Stats.Intervals.values``1(FSharp.Stats.Intervals.Interval{``0})">
<summary>
 Returns min and max value of Interval [min,max]
</summary>
</member>
<member name="M:FSharp.Stats.Intervals.ofSize(System.Int32,System.Int32)">
<summary>
 Creates closed interval [min,max] by given start and size
</summary>
</member>
<member name="M:FSharp.Stats.Intervals.create``1(``0,``0)">
<summary>
 Creates closed interval [min,max] by given min and max
</summary>
</member>
<member name="M:FSharp.Stats.ComplexModule.ofReal(System.Double)">
<summary>
Creates a complex number of a real number (imaginary part 0)
</summary>
</member>
<member name="M:FSharp.Stats.ComplexModule.tan(FSharp.Stats.Complex)">
<summary>
Evaluates the tangent of a complex number
</summary>
</member>
<member name="M:FSharp.Stats.ComplexModule.sin(FSharp.Stats.Complex)">
<summary>
Evaluates the sine of a complex number
</summary>
</member>
<member name="M:FSharp.Stats.ComplexModule.cos(FSharp.Stats.Complex)">
<summary>
Evaluates the cosine of a complex number
</summary>
</member>
<member name="M:FSharp.Stats.ComplexModule.sqrt(FSharp.Stats.Complex)">
<summary>
Evaluates square root of complex number
</summary>
</member>
<member name="M:FSharp.Stats.ComplexModule.log(FSharp.Stats.Complex)">
<summary>
Evaluates natural logarithm of complex number
</summary>
</member>
<member name="M:FSharp.Stats.ComplexModule.exp(FSharp.Stats.Complex)">
<summary>
Evaluates the exponent of the complex number to base e
</summary>
</member>
<member name="P:FSharp.Stats.ComplexModule.pi">
<summary>
Pi as complex number
</summary>
</member>
<member name="M:FSharp.Stats.ComplexModule.iscale(System.Double,FSharp.Stats.Complex)">
<summary>
Rotates a complex number 90ï¿½ counterclockwise and multiplies by scalar k
</summary>
</member>
<member name="M:FSharp.Stats.ComplexModule.muls(FSharp.Stats.Complex,System.Double)">
<summary>
Multiplies complex number a by scalar b
</summary>
</member>
<member name="M:FSharp.Stats.ComplexModule.smul(System.Double,FSharp.Stats.Complex)">
<summary>
Multiplies complex number b by scalar a
</summary>
</member>
<member name="M:FSharp.Stats.ComplexModule.neg(FSharp.Stats.Complex)">
<summary>
Reverses sign of the real and the imaginary part of a complex number
</summary>
</member>
<member name="M:FSharp.Stats.ComplexModule.div(FSharp.Stats.Complex,FSharp.Stats.Complex)">
<summary>
Divides complex number x by complex number y
</summary>
</member>
<member name="M:FSharp.Stats.ComplexModule.mul(FSharp.Stats.Complex,FSharp.Stats.Complex)">
<summary>
Multiplies two complex numbers
</summary>
</member>
<member name="M:FSharp.Stats.ComplexModule.sub(FSharp.Stats.Complex,FSharp.Stats.Complex)">
<summary>
Substracts complex number b from complex number a
</summary>
</member>
<member name="M:FSharp.Stats.ComplexModule.add(FSharp.Stats.Complex,FSharp.Stats.Complex)">
<summary>
Adds two complex numbers
</summary>
</member>
<member name="M:FSharp.Stats.ComplexModule.abs(FSharp.Stats.Complex)">
<summary>
Evaluates the absolute value of a complex number
</summary>
</member>
<member name="M:FSharp.Stats.ComplexModule.imagPart(FSharp.Stats.Complex)">
<summary>
Gets the imaginary part of a complex number
</summary>
</member>
<member name="M:FSharp.Stats.ComplexModule.realPart(FSharp.Stats.Complex)">
<summary>
Gets the real part of a complex number
</summary>
</member>
<member name="M:FSharp.Stats.ComplexModule.phase(FSharp.Stats.Complex)">
<summary>
Evaluates the phase (or the angle) of the complex number in polar form
</summary>
</member>
<member name="M:FSharp.Stats.ComplexModule.magnitude(FSharp.Stats.Complex)">
<summary>
Evalues magnitude of complex number
</summary>
</member>
<member name="P:FSharp.Stats.ComplexModule.onei">
<summary>
Complex number with real part 0 and imaginary part 1
</summary>
</member>
<member name="P:FSharp.Stats.ComplexModule.one">
<summary>
Complex number with real part 1 and imaginary part 0
</summary>
</member>
<member name="P:FSharp.Stats.ComplexModule.zero">
<summary>
Complex number with real part 0 and imaginary part 0
</summary>
</member>
<member name="M:FSharp.Stats.ComplexModule.cis(System.Double)">
<summary>
Creates a complex number on the unit circle with b being the radius
</summary>
</member>
<member name="M:FSharp.Stats.ComplexModule.mkPolar(System.Double,System.Double)">
<summary>
Creates a complex number from its polar form where a is the radius and b is the angle
</summary>
</member>
<member name="M:FSharp.Stats.ComplexModule.conjugate(FSharp.Stats.Complex)">
<summary>
Conjugates a complex number (reverses sign of imaginary part)
</summary>
</member>
<member name="M:FSharp.Stats.ComplexModule.mkRect(System.Double,System.Double)">
<summary>
Creates a complex number of a real part a and an imaginary part b
</summary>
</member>
<member name="T:FSharp.Stats.ComplexModule">
<summary>
Operations for complex number in cartesian form
</summary>
</member>
<member name="M:FSharp.Stats.SpecializedGenericImpl.setColM``1(FSharp.Stats.Matrix{``0},System.Int32,FSharp.Stats.Vector{``0})">
<summary>
Replaces column of index i of matrix a with values of vector v, if vector length matches columnsize
</summary>
</member>
<member name="M:FSharp.Stats.SpecializedGenericImpl.getColM``1(FSharp.Stats.Matrix{``0},System.Int32)">
<summary>
Returns col of index i of matrix a as a vector
</summary>
</member>
<member name="M:FSharp.Stats.SpecializedGenericImpl.setRowM``1(FSharp.Stats.Matrix{``0},System.Int32,FSharp.Stats.Vector{``0})">
<summary>
Replaces row of index j of matrix a with values of vector v, if vector length matches rowsize
</summary>
</member>
<member name="M:FSharp.Stats.SpecializedGenericImpl.getRowM``1(FSharp.Stats.Matrix{``0},System.Int32)">
<summary>
Returns row of index i of matrix a as a vector
</summary>
</member>
<member name="M:FSharp.Stats.SpecializedGenericImpl.mergedNonZeroEntriesM``1(FSharp.Stats.Matrix{``0},FSharp.Stats.Matrix{``0})">
<summary>
 Non-zero entries from two sequences
</summary>
</member>
<member name="M:FSharp.Stats.SpecializedGenericImpl.mergeSorted``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.Int32}},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})">
<summary>
 Merge two sorted sequences
</summary>
</member>
<member name="T:FSharp.Stats.SpecializedGenericImpl">
<summary>
 Generic operations that, when used on floating point types, use the specialized versions in DoubleImpl
</summary>
</member>
<member name="T:FSharp.Stats.DoubleImpl">
<summary>
 Implementations of operations specific to floating point types
</summary>
</member>
<member name="M:FSharp.Stats.GenericImpl.cptMulDenseMatrixGU``1(FSharp.Stats.DenseMatrix{``0},FSharp.Stats.DenseMatrix{``0})">
<summary>
Point-wise multiplication 
</summary>
</member>
<member name="M:FSharp.Stats.GenericImpl.initSparseMatrixGU``1(System.Int32,System.Int32,Microsoft.FSharp.Core.FSharpOption{FSharp.Stats.INumeric{``0}},System.Collections.Generic.IEnumerable{System.Tuple{System.Int32,System.Int32,``0}})">
<summary>
 Create a matrix from a sparse sequence 
</summary>
</member>
<member name="T:FSharp.Stats.GenericImpl">
<summary>
 Implementations of operations that will work for any type
</summary>
</member>
<member name="M:FSharp.Stats.RunningStats.stDevPopulation``2(FSharp.Stats.RunningStats.RunningStats{``0})">

</member>
<member name="M:FSharp.Stats.RunningStats.stDev``2(FSharp.Stats.RunningStats.RunningStats{``0})">

</member>
<member name="M:FSharp.Stats.RunningStats.var``1(FSharp.Stats.RunningStats.RunningStats{``0})">

</member>
<member name="M:FSharp.Stats.RunningStats.varPopulation``1(FSharp.Stats.RunningStats.RunningStats{``0})">

</member>
<member name="M:FSharp.Stats.SummaryStats.stDevPopulation``3(FSharp.Stats.SummaryStats.SummaryStats{``0})">

</member>
<member name="M:FSharp.Stats.SummaryStats.stDev``4(FSharp.Stats.SummaryStats.SummaryStats{``0})">

</member>
<member name="M:FSharp.Stats.SummaryStats.var``3(FSharp.Stats.SummaryStats.SummaryStats{``0})">

</member>
<member name="M:FSharp.Stats.SummaryStats.varPopulation``2(FSharp.Stats.SummaryStats.SummaryStats{``0})">

</member>
<member name="M:FSharp.Stats.SummaryStats.mean``1(FSharp.Stats.SummaryStats.SummaryStats{``0})">

</member>
<member name="T:FSharp.Stats.SummaryStats">
<summary>
 Module to compute common statistical measure on 
</summary>
</member>
<member name="M:FSharp.Stats.Array.seqInit(System.Double,System.Double,System.Int32)">
<summary>
 Generates array sequence (like R! seq.int)
</summary>
</member>
<member name="M:FSharp.Stats.Array.shuffleFisherYates``1(``0[])">
<summary>
 Shuffels the input array (method: Fisher-Yates)
</summary>
</member>
<member name="M:FSharp.Stats.Array.sampleWithOutReplacement``1(System.Random,``0[],System.Int32)">
<summary>
 Samples from an array of obj without replacement (without putting back)
</summary>
</member>
<member name="M:FSharp.Stats.Array.sampleWithReplacement``1(System.Random,``0[],System.Int32)">
<summary>
 Samples from an array of obj wit replacement (with putting back)
</summary>
</member>
<member name="M:FSharp.Stats.Array.median``2(``0[])">
<summary>
 Computes the sample median
</summary>
</member>
<member name="M:FSharp.Stats.Array.quickSelectInPlace``1(System.Int32,``0[])">
<summary>
 Finds the kth smallest element in an unordered array
 Works in place and can change the order of the elements in the input array
</summary>
</member>
<member name="M:FSharp.Stats.Array.quickSelect``1(System.Int32,``0[])">
<summary>
 Finds the kth smallest element in an unordered array
</summary>
</member>
<member name="M:FSharp.Stats.Array.partitionSortInPlace``1(System.Int32,System.Int32,``0[])">
<summary>
 Arranges the items between the left and right border, that all items left of the pivot element are smaller and bigger on the right.
 Function works in place and returns the index of the pivote element
</summary>
</member>
<member name="T:FSharp.Stats.Array">
<summary>
 Module to compute common statistical measure on array
</summary>
</member>
<member name="M:FSharp.Stats.Seq.stats``3(System.Collections.Generic.IEnumerable{``0})">
<summary>
 Returns SummeryStats of deq with N, mean, sum-of-squares, minimum and maximum
</summary>
</member>
<member name="M:FSharp.Stats.Seq.medianAbsoluteDev(System.Collections.Generic.IEnumerable{System.Double})">
<summary>
 Median absolute deviation (MAD)
</summary>
</member>
<member name="M:FSharp.Stats.Seq.cvPopulationBy``5(Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.Collections.Generic.IEnumerable{``0})">
 <summary>
   Computes the Coefficient of Variation of the population (population standard deviation)
 </summary>

 <param name="f">A function applied to transform each element of the sequence.</param>
 <param name="items">The input sequence.</param>
 <remarks>Returns NaN if data is empty or if any entry is NaN.</remarks>
 <returns>Coefficient of Variation of the population</returns> 
</member>
<member name="M:FSharp.Stats.Seq.cvPopulation``4(System.Collections.Generic.IEnumerable{``0})">
 <summary>
   Computes the Coefficient of Variation of the population (population standard deviation)
 </summary>

 <param name="items">The input sequence.</param>
 <remarks>Returns NaN if data is empty or if any entry is NaN.</remarks>
 <returns>Coefficient of Variation of the population</returns> 
</member>
<member name="M:FSharp.Stats.Seq.cvBy``5(Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.Collections.Generic.IEnumerable{``0})">
 <summary>
   Computes the Coefficient of Variation of a sample (Bessel's correction by N-1)
 </summary>

 <param name="f">A function applied to transform each element of the sequence.</param>
 <param name="items">The input sequence.</param>
 <remarks>Returns NaN if data is empty or if any entry is NaN.</remarks>
 <returns>Coefficient of Variation of a sample (Bessel's correction by N-1)</returns> 
</member>
<member name="M:FSharp.Stats.Seq.cv``4(System.Collections.Generic.IEnumerable{``0})">
 <summary>
   Computes the Coefficient of Variation of a sample (Bessel's correction by N-1)
 </summary>

 <param name="items">The input sequence.</param>
 <remarks>Returns NaN if data is empty or if any entry is NaN.</remarks>
 <returns>Coefficient of Variation of a sample (Bessel's correction by N-1)</returns> 
</member>
<member name="M:FSharp.Stats.Seq.stDevPopulationBy``5(Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.Collections.Generic.IEnumerable{``0})">
 <summary>
   Computes the population standard deviation (denominator = N)
 </summary>

 <param name="f">A function applied to transform each element of the sequence.</param>
 <param name="items">The input sequence.</param>
 <remarks>Returns NaN if data is empty or if any entry is NaN.</remarks>
 <returns>population standard deviation (denominator = N)</returns>     
</member>
<member name="M:FSharp.Stats.Seq.stDevPopulation``4(System.Collections.Generic.IEnumerable{``0})">
 <summary>
   Computes the population standard deviation (denominator = N)
 </summary>

 <param name="items">The input sequence.</param>
 <remarks>Returns NaN if data is empty or if any entry is NaN.</remarks>
 <returns>population standard deviation (denominator = N)</returns>     
</member>
<member name="M:FSharp.Stats.Seq.stDevBy``5(Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.Collections.Generic.IEnumerable{``0})">
 <summary>
   Computes the sample standard deviation
 </summary>

 <param name="f">A function applied to transform each element of the sequence.</param>
 <param name="items">The input sequence.</param>
 <remarks>Returns NaN if data is empty or if any entry is NaN.</remarks>
 <returns>standard deviation of a sample (Bessel's correction by N-1)</returns> 
</member>
<member name="M:FSharp.Stats.Seq.stDev``4(System.Collections.Generic.IEnumerable{``0})">
 <summary>
   Computes the sample standard deviation
 </summary>

 <param name="items">The input sequence.</param>
 <remarks>Returns NaN if data is empty or if any entry is NaN.</remarks>
 <returns>standard deviation of a sample (Bessel's correction by N-1)</returns> 
</member>
<member name="M:FSharp.Stats.Seq.varPopulationBy``4(Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.Collections.Generic.IEnumerable{``0})">
 <summary>
   Computes variance of the given values (denominator N)
 </summary>
    
 <param name="f">A function applied to transform each element of the sequence.</param>
 <param name="items">The input sequence.</param>
 <remarks>Returns NaN if data is empty or if any entry is NaN.</remarks>
 <returns>population variance estimator (denominator N)</returns> 
</member>
<member name="M:FSharp.Stats.Seq.varPopulation``3(System.Collections.Generic.IEnumerable{``0})">
 <summary>
   Computes variance of the given values (denominator N)
 </summary>
    
 <param name="items">The input sequence.</param>
 <remarks>Returns NaN if data is empty or if any entry is NaN.</remarks>
 <returns>population variance estimator (denominator N)</returns> 
</member>
<member name="M:FSharp.Stats.Seq.varBy``4(Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.Collections.Generic.IEnumerable{``0})">
 <summary>
   Computes the sample variance (Bessel's correction by N-1)
 </summary>

 <param name="f">A function applied to transform each element of the sequence.</param>
 <param name="items">The input sequence.</param>
 <remarks>Returns NaN if data is empty or if any entry is NaN.</remarks>
 <returns>variance of a sample (Bessel's correction by N-1)</returns> 
</member>
<member name="M:FSharp.Stats.Seq.var``3(System.Collections.Generic.IEnumerable{``0})">
 <summary>
   Computes the sample variance (Bessel's correction by N-1)
 </summary>

 <param name="items">The input sequence.</param>
 <remarks>Returns NaN if data is empty or if any entry is NaN.</remarks>
 <returns>variance of a sample (Bessel's correction by N-1)</returns> 
</member>
<member name="M:FSharp.Stats.Seq.median``2(System.Collections.Generic.IEnumerable{``0})">
<summary>
 Sample Median
</summary>
</member>
<member name="M:FSharp.Stats.Seq.meanTruncatedBy``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.Double,System.Collections.Generic.IEnumerable{``0})">
 <summary>
   Computes the truncated (trimmed) mean
 </summary>

 <param name="items">The input sequence.</param>
 <param name="f">A function applied to transform each element of the sequence.</param>    
 <remarks>Returns NaN if data is empty or if any entry is NaN.</remarks>
 <returns>truncated (trimmed) mean</returns>  
</member>
<member name="M:FSharp.Stats.Seq.meanTruncated``2(System.Double,System.Collections.Generic.IEnumerable{``0})">
 <summary>
   Computes the truncated (trimmed) mean
 </summary>

 <param name="items">The input sequence.</param>
 <remarks>Returns NaN if data is empty or if any entry is NaN.</remarks>
 <returns>truncated (trimmed) mean</returns>  
</member>
<member name="M:FSharp.Stats.Seq.meanGeometricBy``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.Collections.Generic.IEnumerable{``0})">
 <summary>
   Computes gemetric mean
 </summary>

 <param name="f">A function applied to transform each element of the sequence.</param>
 <param name="items">The input sequence.</param>
 <remarks>Returns NaN if data is empty or if any entry is NaN.</remarks>
 <returns>gemetric mean</returns>   
</member>
<member name="M:FSharp.Stats.Seq.meanGeometric``2(System.Collections.Generic.IEnumerable{``0})">
 <summary>
   Computes gemetric mean
 </summary>

 <param name="items">The input sequence.</param>
 <remarks>Returns NaN if data is empty or if any entry is NaN.</remarks>
 <returns>gemetric mean</returns>   
</member>
<member name="M:FSharp.Stats.Seq.meanHarmonicBy``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.Collections.Generic.IEnumerable{``0})">
 <summary>
   Computes harmonic mean
 </summary>

 <param name="f">A function applied to transform each element of the sequence.</param>
 <param name="items">The input sequence.</param>
 <remarks>Returns NaN if data is empty or if any entry is NaN.</remarks>
 <returns>harmonic mean</returns>   
</member>
<member name="M:FSharp.Stats.Seq.meanHarmonic``3(System.Collections.Generic.IEnumerable{``0})">
 <summary>
   Computes harmonic mean
 </summary>

 <param name="items">The input sequence.</param>
 <remarks>Returns NaN if data is empty or if any entry is NaN.</remarks>
 <returns>harmonic mean</returns>   
</member>
<member name="M:FSharp.Stats.Seq.meanBy``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.Collections.Generic.IEnumerable{``0})">
 <summary>
   Computes the population mean (Normalized by N)s
 </summary>

 <param name="f">A function applied to transform each element of the sequence.</param>
 <param name="items">The input sequence.</param>
 <remarks>Returns NaN if data is empty or if any entry is NaN.</remarks>
 <returns>population mean (Normalized by N)</returns>   
</member>
<member name="M:FSharp.Stats.Seq.mean``2(System.Collections.Generic.IEnumerable{``0})">
 <summary>
   Computes the population mean (Normalized by N)
 </summary>

 <param name="items">The input sequence.</param>
 <remarks>Returns default value if data is empty or if any entry is NaN.</remarks>
 <returns>population mean (Normalized by N)</returns>   
</member>
<member name="M:FSharp.Stats.Seq.UtilityFunctions.pooledStDevPopulation``1(System.Collections.Generic.IEnumerable{``0})">
 <summary>
   Computes the pooled population standard deviation of the given values (Bessel's correction by N-1)
 </summary>       
</member>
<member name="M:FSharp.Stats.Seq.UtilityFunctions.pooledStDevPopulationOf(System.Collections.Generic.IEnumerable{System.Int32},System.Collections.Generic.IEnumerable{System.Double})">
 <summary>
   Computes the pooled population standard deviation of the given values (Bessel's correction by N-1)
 </summary>

 <param name="sizes">The number of samples</param>
 <param name="variances">The population variances for each samples.</param>       
</member>
<member name="M:FSharp.Stats.Seq.UtilityFunctions.pooledStDev``1(System.Collections.Generic.IEnumerable{``0})">
 <summary>
   Computes the pooled standard deviation of the given values.
 </summary>       
</member>
<member name="M:FSharp.Stats.Seq.UtilityFunctions.pooledStDevOf(System.Collections.Generic.IEnumerable{System.Int32},System.Collections.Generic.IEnumerable{System.Double})">
 <summary>
   Computes the pooled standard deviation of the given values
 </summary>

 <param name="sizes">The number of samples</param>
 <param name="variances">The population variances for each samples.</param>       
</member>
<member name="M:FSharp.Stats.Seq.UtilityFunctions.pooledVarPopulation``1(System.Collections.Generic.IEnumerable{``0})">
 <summary>
   Computes the pooled population variance of the given values (Bessel's correction by N-1)
 </summary>
</member>
<member name="M:FSharp.Stats.Seq.UtilityFunctions.pooledVarPopulationOf(System.Collections.Generic.IEnumerable{System.Int32},System.Collections.Generic.IEnumerable{System.Double})">
 <summary>
   Computes the pooled population variance of the given values (Bessel's correction by N-1)
 </summary>
 
 <param name="sizes">The number of samples</param>
 <param name="variances">The population variances for each samples.</param>
</member>
<member name="M:FSharp.Stats.Seq.UtilityFunctions.pooledVar``1(System.Collections.Generic.IEnumerable{``0})">
 <summary>
   Computes the pooled variance of the given values
 </summary>
</member>
<member name="M:FSharp.Stats.Seq.UtilityFunctions.pooledVarOf(System.Collections.Generic.IEnumerable{System.Int32},System.Collections.Generic.IEnumerable{System.Double})">
 <summary>
   Computes the pooled variance of the given values
 </summary>
 
 <param name="sizes">The number of samples</param>
 <param name="variances">The population variances for each samples.</param>
</member>
<member name="M:FSharp.Stats.Seq.UtilityFunctions.sumOfSquares(System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Double})">
 <summary>
   Computes sum of squares
 </summary>

 <param name="items">seq of float</param>
 <remarks>Returns NaN if data is empty or if any entry is NaN.</remarks>
 <returns>sum of squares</returns> 
</member>
<member name="T:FSharp.Stats.Seq.UtilityFunctions">
<summary>
 A module which implements helper functions to provide special statistical measures
</summary>
</member>
<member name="T:FSharp.Stats.Seq">
<summary>
 Module to compute common statistical measure
</summary>
</member>
<member name="M:FSharp.Stats.List.median``1(Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Calculate the median of a list of items.
 The result is a tuple of two items whose mean is the median.
</summary>
</member>
<member name="M:FSharp.Stats.List.mean(Microsoft.FSharp.Collections.FSharpList{System.Double})">
<summary>
 computes the population mean (normalized by n)
</summary>
</member>
<member name="T:FSharp.Stats.List">
<summary>
 Module to compute common statistical measure on list
</summary>
</member>
<member name="M:FSharp.Stats.JaggedList.innerChoose``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}},Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Collections.FSharpList{``0}})">
<summary>
Applies the given function to each element in the inner lists of the jagged List. Returns the jagged list whose inner lists are comprised of the results x for each element where the function returns Some(x)
</summary>
</member>
<member name="M:FSharp.Stats.JaggedList.innerFilter``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Collections.FSharpList{``0}})">
<summary>
Returns a new jagged list whose inner lists only contain the elements for which the given predicate returns true
</summary>
</member>
<member name="M:FSharp.Stats.JaggedList.fold``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}},Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Core.FSharpFunc{``0,``2}},``0,``2,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Collections.FSharpList{``1}})">
<summary>
Applies a function to each element of the inner lists of the jagged list, threading an accumulator argument through the computation. 
A second function is the applied to each result of the predeceding computation, again passing an accumulater through the computation 
</summary>
</member>
<member name="M:FSharp.Stats.JaggedList.innerFold``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}},``0,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Collections.FSharpList{``1}})">
<summary>
Applies a function to each element of the inner lists of the jagged list, threading an accumulator argument through the computation.
</summary>
</member>
<member name="M:FSharp.Stats.JaggedList.mapi``2(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,``1}},Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Collections.FSharpList{``0}})">
<summary>
Builds a new jagged list whose inner lists are the results of applying the given function to each of their elements. The integer index passed to the function indicates the index of element in the inner list being transformed.
</summary>
</member>
<member name="M:FSharp.Stats.JaggedList.map3``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,``3}}},Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Collections.FSharpList{``0}},Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Collections.FSharpList{``1}},Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Collections.FSharpList{``2}})">
<summary>
 Builds a new jagged list whose inner lists are the results of applying the given function to the corresponding elements of the inner lists of the tree jagged lists triplewise. 
 All corresponding inner lists must be of the same length, otherwise ArgumentException is raised.
</summary>
</member>
<member name="M:FSharp.Stats.JaggedList.map2``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Collections.FSharpList{``0}},Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Collections.FSharpList{``1}})">
<summary>
 Builds a new jagged list whose inner lists are the results of applying the given function to the corresponding elements of the inner lists of the two jagged lists pairwise. 
 All corresponding inner lists must be of the same length, otherwise ArgumentException is raised.
</summary>
</member>
<member name="M:FSharp.Stats.JaggedList.map``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Collections.FSharpList{``0}})">
<summary>
 Builds a new jagged list whose inner lists are the results of applying the given function to each of their elements.
</summary>
</member>
<member name="M:FSharp.Stats.JaggedArray.shuffleInPlace``1(``0[][])">
<summary>
 Shuffels a jagged array (method: Fisher-Yates)
</summary>
</member>
<member name="M:FSharp.Stats.JaggedArray.shuffleRowWiseInPlace``1(``0[][])">
<summary>
 Shuffles each row of a jagged array separately  (method: Fisher-Yates)
</summary>
</member>
<member name="M:FSharp.Stats.JaggedArray.shuffleColumnWiseInPlace``1(``0[][])">
<summary>
 Shuffles each column of a jagged array separately  (method: Fisher-Yates)
</summary>
</member>
<member name="M:FSharp.Stats.JaggedArray.innerChoose``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}},``0[][])">
<summary>
Applies the given function to each element in the inner arrays of the jagged array. Returns the jagged array whose inner arrays are comprised of the results x for each element where the function returns Some(x)
</summary>
</member>
<member name="M:FSharp.Stats.JaggedArray.innerFilter``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},``0[][])">
<summary>
Returns a new jagged array whose inner arrays only contain the elements for which the given predicate returns true
</summary>
</member>
<member name="M:FSharp.Stats.JaggedArray.fold``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}},Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Core.FSharpFunc{``0,``2}},``0,``2,``1[][])">
<summary>
Applies a function to each element of the inner arrays of the jagged array, threading an accumulator argument through the computation. 
A second function is the applied to each result of the predeceding computation, again passing an accumulater through the computation 
</summary>
</member>
<member name="M:FSharp.Stats.JaggedArray.innerFold``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}},``0,``1[][])">
<summary>
Applies a function to each element of the inner arrays of the jagged array, threading an accumulator argument through the computation.
</summary>
</member>
<member name="M:FSharp.Stats.JaggedArray.mapi``2(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,``1}},``0[][])">
<summary>
Builds a new jagged array whose inner arrays are the results of applying the given function to each of their elements. The integer index passed to the function indicates the index of element in the inner array being transformed.
</summary>
</member>
<member name="M:FSharp.Stats.JaggedArray.map3``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,``3}}},``0[][],``1[][],``2[][])">
<summary>
 Builds a new jagged array whose inner arrays are the results of applying the given function to the corresponding elements of the inner arrays of the tree jagged arrays triplewise. 
 All corresponding inner arrays must be of the same length, otherwise ArgumentException is raised.
</summary>
</member>
<member name="M:FSharp.Stats.JaggedArray.map2``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},``0[][],``1[][])">
<summary>
 Builds a new jagged array whose inner arrays are the results of applying the given function to the corresponding elements of the inner arrays of the two jagged arrays pairwise. 
 All corresponding inner arrays must be of the same length, otherwise ArgumentException is raised.
</summary>
</member>
<member name="M:FSharp.Stats.JaggedArray.map``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``0[][])">
<summary>
 Builds a new jagged array whose inner arrays are the results of applying the given function to each of their elements.
</summary>
</member>
<member name="M:FSharp.Stats.JaggedArray.toJaggedSeq``1(``0[][])">
<summary>
 Converts a jagged array into a jagged seq
</summary>
</member>
<member name="M:FSharp.Stats.JaggedArray.ofJaggedSeq``2(System.Collections.Generic.IEnumerable{``0})">
<summary>
 Converts a jagged Seq into a jagged array
</summary>
</member>
<member name="M:FSharp.Stats.JaggedArray.toJaggedList``1(``0[][])">
<summary>
 Converts a jagged array into a jagged list
</summary>
</member>
<member name="M:FSharp.Stats.JaggedArray.ofJaggedList``1(Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Collections.FSharpList{``0}})">
<summary>
 Converts a jagged list into a jagged array
</summary>
</member>
<member name="M:FSharp.Stats.JaggedArray.transpose``1(``0[][])">
<summary>
 Transposes a jagged array
</summary>
</member>
<member name="M:FSharp.Stats.JaggedArray.copy``1(``0[][])">
<summary>
 Copies the jagged array
</summary>
</member>
<member name="M:FSharp.Stats.VectorModule.cov(FSharp.Stats.Vector{System.Double},FSharp.Stats.Vector{System.Double})">
<summary>
 Returns the sample covariance of two random variables v1 and v2. (Bessel&apos;s correction by N-1) 
</summary>
</member>
<member name="M:FSharp.Stats.VectorModule.covPopulation(FSharp.Stats.Vector{System.Double},FSharp.Stats.Vector{System.Double})">
<summary>
 Returns an estimator of the population covariance of two random variables v1 and v2 
</summary>
</member>
<member name="M:FSharp.Stats.VectorModule.stats``3(FSharp.Stats.Vector{``0})">
<summary>
 Returns SummaryStats of vector with N, mean, sum-of-squares, minimum and maximum
</summary>
</member>
<member name="M:FSharp.Stats.VectorModule.median``2(FSharp.Stats.Vector{``0})">
<summary>
 Computes the sample median
</summary>
</member>
<member name="M:FSharp.Stats.VectorModule.mean``2(FSharp.Stats.Vector{``0})">
<summary>
 Computes the population mean (Normalized by N)            
</summary>
</member>
<member name="M:FSharp.Stats.VectorModule.interval``1(FSharp.Stats.Vector{``0})">

</member>
<member name="M:FSharp.Stats.VectorModule.raw``1(FSharp.Stats.Vector{``0})">
<summary>
 Returns the raw data array without copy
</summary>
</member>
<member name="M:FSharp.Stats.VectorModule.of_scalar(System.Double)">
<summary>
Builds one dimensional vector from scalar
</summary>
</member>
<member name="M:FSharp.Stats.VectorModule.of_seq(System.Collections.Generic.IEnumerable{System.Double})">
<summary>
Builds vector from sequence
</summary>
</member>
<member name="M:FSharp.Stats.VectorModule.of_list(Microsoft.FSharp.Collections.FSharpList{System.Double})">
<summary>
Builds vector from list
</summary>
</member>
<member name="M:FSharp.Stats.VectorModule.to_array(FSharp.Stats.Vector{System.Double})">
<summary>
Builds array from vector
</summary>
</member>
<member name="M:FSharp.Stats.VectorModule.of_array(System.Double[])">
<summary>
Builds vector from array
</summary>
</member>
<member name="M:FSharp.Stats.VectorModule.cptPow(FSharp.Stats.Vector{System.Double},System.Double)">
<summary>
Builds a new vector whose elements are the results of exponentiating each of the elements of the vector.
</summary>
</member>
<member name="M:FSharp.Stats.VectorModule.norm(FSharp.Stats.Vector{System.Double})">
<summary>
Euklidian norm of the vector
</summary>
</member>
<member name="M:FSharp.Stats.VectorModule.prod(FSharp.Stats.Vector{System.Double})">
<summary>
Product of all elements of the vector
</summary>
</member>
<member name="M:FSharp.Stats.VectorModule.sum(FSharp.Stats.Vector{System.Double})">
<summary>
Sum of all elements of the vector
</summary>
</member>
<member name="M:FSharp.Stats.VectorModule.ones(System.Int32)">
<summary>
Creates a vector of length n and fills it with ones
</summary>
</member>
<member name="M:FSharp.Stats.VectorModule.zero(System.Int32)">
<summary>
Creates a vector of length n and fills it with zeros
</summary>
</member>
<member name="M:FSharp.Stats.VectorModule.foldi``1(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{System.Double,``0}}},``0,FSharp.Stats.Vector{System.Double})">
<summary>
Applies a function to each element of the vector and their corresponding index, threading an accumulator argument through the computation.
</summary>
</member>
<member name="M:FSharp.Stats.VectorModule.fold``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{System.Double,``0}},``0,FSharp.Stats.Vector{System.Double})">
<summary>
Applies a function to each element of the vector, threading an accumulator argument through the computation.
</summary>
</member>
<member name="M:FSharp.Stats.VectorModule.mapi(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Double,System.Double}},FSharp.Stats.Vector{System.Double})">
<summary>
Builds a new vector whose elements are the results of applying the given function to each of the elements of the vector and their corresponding index.
</summary>
</member>
<member name="M:FSharp.Stats.VectorModule.copy(FSharp.Stats.Vector{System.Double})">
<summary>
Builds a new vector that contains the elements of the given vector.
</summary>
</member>
<member name="M:FSharp.Stats.VectorModule.map2(Microsoft.FSharp.Core.FSharpFunc{System.Double,Microsoft.FSharp.Core.FSharpFunc{System.Double,System.Double}},FSharp.Stats.Vector{System.Double},FSharp.Stats.Vector{System.Double})">
<summary>
Builds a new vector whose elements are the results of applying the given function to the corresponding elements of the two vectors pairwise. The two input vectors must have the same lengths, otherwise ArgumentException is raised.
</summary>
</member>
<member name="M:FSharp.Stats.VectorModule.map(Microsoft.FSharp.Core.FSharpFunc{System.Double,System.Double},FSharp.Stats.Vector{System.Double})">
<summary>
Builds a new vector whose elements are the results of applying the given function to each of the elements of the vector.
</summary>
</member>
<member name="M:FSharp.Stats.VectorModule.dot(FSharp.Stats.Vector{System.Double},FSharp.Stats.Vector{System.Double})">
<summary>
Dot product of the two vectors
</summary>
</member>
<member name="M:FSharp.Stats.VectorModule.neg(FSharp.Stats.Vector{System.Double})">
<summary>
Builds a new vector whose elements are the results of multiplying -1 with each of the elements of the vector.
</summary>
</member>
<member name="M:FSharp.Stats.VectorModule.scale(System.Double,FSharp.Stats.Vector{System.Double})">
<summary>
Builds a new vector whose elements are the results of multiplying the given scalar with each of the elements of the vector.
</summary>
</member>
<member name="M:FSharp.Stats.VectorModule.cptMul(FSharp.Stats.Vector{System.Double},FSharp.Stats.Vector{System.Double})">
<summary>
Builds a new vector whose elements are the results of multiplying the corresponding elements of the given vectors. The two input vectors must have the same lengths, otherwise ArgumentException is raised.
</summary>
</member>
<member name="M:FSharp.Stats.VectorModule.sub(FSharp.Stats.Vector{System.Double},FSharp.Stats.Vector{System.Double})">
<summary>
Builds a new vector whose elements are the results of substracting the corresponding elements of vector b from vector a. The two input vectors must have the same lengths, otherwise ArgumentException is raised.
</summary>
</member>
<member name="M:FSharp.Stats.VectorModule.add(FSharp.Stats.Vector{System.Double},FSharp.Stats.Vector{System.Double})">
<summary>
Builds a new vector whose elements are the results of adding the corresponding elements of the two vectors pairwise. The two input vectors must have the same lengths, otherwise ArgumentException is raised.
</summary>
</member>
<member name="M:FSharp.Stats.VectorModule.ofScalar(System.Double)">
<summary>
Creates one dimensional vector of value x
</summary>
</member>
<member name="M:FSharp.Stats.VectorModule.create(System.Int32,System.Double)">
<summary>
Creates vector of length i and fills it with value x
</summary>
</member>
<member name="M:FSharp.Stats.VectorModule.ofSeq(System.Collections.Generic.IEnumerable{System.Double})">
<summary>
Creates vector with values of sequence xs
</summary>
</member>
<member name="M:FSharp.Stats.VectorModule.ofList(Microsoft.FSharp.Collections.FSharpList{System.Double})">
<summary>
Creates vector with values of list xs
</summary>
</member>
<member name="M:FSharp.Stats.VectorModule.toArray(FSharp.Stats.Vector{System.Double})">
<summary>
Creates array with values of vector m
</summary>
</member>
<member name="M:FSharp.Stats.VectorModule.ofArray(System.Double[])">
<summary>
Creates vector with values of array arr
</summary>
</member>
<member name="M:FSharp.Stats.VectorModule.init(System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,System.Double})">
<summary>
Initiates vector of length m and fills it by applying function f on indices
</summary>
</member>
<member name="M:FSharp.Stats.VectorModule.nrows(FSharp.Stats.Vector{System.Double})">
<summary>
Returns length of vector a
</summary>
</member>
<member name="M:FSharp.Stats.VectorModule.length(FSharp.Stats.Vector{System.Double})">
<summary>
Returns length of vector a
</summary>
</member>
<member name="M:FSharp.Stats.VectorModule.set(FSharp.Stats.Vector{System.Double},System.Int32,System.Double)">
<summary>
Sets the value x to the vector a at the given index j
</summary>
</member>
<member name="M:FSharp.Stats.VectorModule.get(FSharp.Stats.Vector{System.Double},System.Int32)">
<summary>
Returns the value of the vector a at the given index j
</summary>
</member>
<member name="M:FSharp.Stats.VectorModule.SummaryStats.ofVector(FSharp.Stats.Vector{System.Int32})">
<summary>
 Returns SummaryStats of vector with N, mean, sum-of-squares, minimum and maximum
</summary>
</member>
<member name="T:FSharp.Stats.VectorModule.SummaryStats">
<summary>
 Module to compute common statistical measure on 
</summary>
</member>
<member name="M:FSharp.Stats.VectorModule.Generic.sum``1(FSharp.Stats.Vector{``0})">
<summary>
Sum of all elements of the vector a
</summary>
</member>
<member name="M:FSharp.Stats.VectorModule.Generic.dot``1(FSharp.Stats.Vector{``0},FSharp.Stats.Vector{``0})">
<summary>
Dot product of the two vectors
</summary>
</member>
<member name="M:FSharp.Stats.VectorModule.Generic.ofSeq``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
Creates vector from seq xss
</summary>
</member>
<member name="M:FSharp.Stats.VectorModule.Generic.ofList``1(Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
Creates vector from list xss
</summary>
</member>
<member name="M:FSharp.Stats.VectorModule.Generic.length``1(FSharp.Stats.Vector{``0})">
<summary>
Returns length of vector v
</summary>
</member>
<member name="M:FSharp.Stats.VectorModule.Generic.set``1(FSharp.Stats.Vector{``0},System.Int32,``0)">
<summary>
Sets the value x to the vector a at the given index i
</summary>
</member>
<member name="M:FSharp.Stats.VectorModule.Generic.get``1(FSharp.Stats.Vector{``0},System.Int32)">
<summary>
Returns the value of the vector a at the given index i
</summary>
</member>
<member name="T:FSharp.Stats.VectorModule">
<summary>
Basic vector operations
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.flattenColWise(FSharp.Stats.Matrix{System.Double})">
<summary>
 Iterates the given Matrix column wise and places every element in a new vector with length n*m.
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.flattenRowWise(FSharp.Stats.Matrix{System.Double})">
<summary>
 Iterates the given Matrix row wise and places every element in a new vector with length n*m.
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.mapiCols``1(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{FSharp.Stats.Vector{System.Double},``0}},FSharp.Stats.Matrix{System.Double})">
<summary>
 Maps every matrix column using the position dependant function
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.enumerateColumnWise``1(Microsoft.FSharp.Core.FSharpFunc{System.Collections.Generic.IEnumerable{System.Double},``0},FSharp.Stats.Matrix{System.Double})">
<summary>
 Applies function f along column axis 
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.mapiRows``1(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{FSharp.Stats.RowVector{System.Double},``0}},FSharp.Stats.Matrix{System.Double})">
<summary>
 Maps every matrix row using the position dependant function
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.enumerateRowWise``1(Microsoft.FSharp.Core.FSharpFunc{System.Collections.Generic.IEnumerable{System.Double},``0},FSharp.Stats.Matrix{System.Double})">
<summary>
 Applies function f along row axis 
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.rowSampleCovarianceMatrixOf(FSharp.Stats.Matrix{System.Double})">
<summary>
 computes the row specific sample covariance matrix of a data matrix 
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.rowPopulationCovarianceMatrixOf(FSharp.Stats.Matrix{System.Double})">
<summary>
 computes the row specific population covariance matrix of a data matrix 
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.columnSampleCovarianceMatrixOf(FSharp.Stats.Matrix{System.Double})">
<summary>
 computes the column specific sample covariance matrix of a data matrix
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.columnPopulationCovarianceMatrixOf(FSharp.Stats.Matrix{System.Double})">
<summary>
 computes the column specific population covariance matrix of a data matrix 
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.columnCovarianceMatrixOf(System.Int32,FSharp.Stats.Matrix{System.Double})">
<summary>
 computes the column specific covariance matrix of a data matrix as described at:
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.meanColumnWise(FSharp.Stats.Matrix{System.Double})">
<summary>
 Computes the Column wise mean of a Matrix 
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.meanRowWise(FSharp.Stats.Matrix{System.Double})">
<summary>
 Computes the row wise mean of a Matrix 
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.toDiagonal(FSharp.Stats.Matrix{System.Double})">
<summary>
 Returns diagonal matrix by setting all values beneath and above the diagonal to Zero.
 Warning: diagonal matrices can only be computed for square input matrices.
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.getLowerTriangular(FSharp.Stats.Matrix{System.Double})">
<summary>
 Returns lower triangular Matrix by setting all values beneath the diagonal to Zero.
 Warning: triangular matrices can only be computed for square input matrices.
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.getUpperTriangular(FSharp.Stats.Matrix{System.Double})">
<summary>
 Returns upper triangular Matrix by setting all values beneath the diagonal to Zero.  
 Warning: triangular matrices can only be computed for square input matrices.
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.getRegion(FSharp.Stats.Matrix{System.Double},System.Int32,System.Int32,System.Int32,System.Int32)">
<summary>
 Accesses the m*n matrix a and returns a total of i2 rows and j2 columns starting from row index i1 and colum index j1. The Result is a new
 i2*j2 matrix.
 Only usable if (i1+i2-1) does not exceed m and (j1+j2-1) does not exceed n.
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.getRows(FSharp.Stats.Matrix{System.Double},System.Int32,System.Int32)">
<summary>
 Accesses the m*n matrix a and returns a total of i2 rows starting from row index i1. The Result is a new
 i2*n matrix.
 Only usable if (i1+i2-1) does not exceed m.
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.getCols(FSharp.Stats.Matrix{System.Double},System.Int32,System.Int32)">
<summary>
 Accesses the m*n matrix a and returns a total of j2 Columns starting from column index j1. The Result is a new
 m*j2 matrix.
 Only usable if (j1+j2-1) does not exceed n.
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.setCol``1(FSharp.Stats.Matrix{``0},System.Int32,FSharp.Stats.Vector{``0})">
<summary>
 Replaces column of index j of matrix a with values of vector v, if vector length matches columnsize
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.getCol(FSharp.Stats.Matrix{System.Double},System.Int32)">
<summary>
 Returns col of index j of matrix a
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.setRow``1(FSharp.Stats.Matrix{``0},System.Int32,FSharp.Stats.Vector{``0})">
<summary>
 Replaces row of index i of matrix a with values of vector v, if vector length matches rowsize
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.getRow(FSharp.Stats.Matrix{System.Double},System.Int32)">
<summary>
 Returns row of index i of matrix a    
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.ones(System.Int32,System.Int32)">
<summary>
 Creates a dense matrix with i rows and j columns. All values are initialized to one (1.).
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.identity(System.Int32)">
<summary>
 Creates a dense identiy m*m matrix. A identity matrix is always squared and the elements are set to zero exept elements
 on the diagonal, which are set to 1.
 e.g.
 [[1.;0.;0.]
  [0.;1.;0.]
  [0.;0.;1.]]
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.zero(System.Int32,System.Int32)">
<summary>
 Creates a dense matrix with i rows and j columns. All values are initialized to yero (0.).
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.nonzero_entries(FSharp.Stats.Matrix{System.Double})">
<summary>
 Iterates the m*n matrix a row wise and returns a list of tuples (mi,ni,v) containing non zero elements of a
 and their row (m) and column (n) indicies. 
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.initSparse(System.Int32,System.Int32,System.Collections.Generic.IEnumerable{System.Tuple{System.Int32,System.Int32,System.Double}})">
<summary>
 Creates a sparse matrix with i rows and j columns. All values are initialized to the value of a.
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.initDense(System.Int32,System.Int32,System.Collections.Generic.IEnumerable{System.Tuple{System.Int32,System.Int32,System.Double}})">
<summary>
 Creates a dense matrix with i rows and j columns. All values are initialized to the value of a.
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.toDense(FSharp.Stats.Matrix{System.Double})">
<summary>
 Transforms the matrix a to a dense matrix representation
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.foldi``1(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{System.Double,``0}}}},``0,FSharp.Stats.Matrix{System.Double})">
<summary>
 Applies a function f row wise to each element of the matrix, threading an accumulator argument through the computation.
 The fold function takes the second argument, and applies the function f to it and the first element of the matrix.
 Then, it feeds this result into the function f along with the second element, and so on. It returns the final result.
 If the input function is f and the elements are i0...iN, then this function computes f (... (f s i0) i1 ...) iN.   
 The integers indicies passed to the function indicate row and column position (from 0) the of the element being transformed.
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.fold``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{System.Double,``0}},``0,FSharp.Stats.Matrix{System.Double})">
<summary>
 Applies a function f row wise to each element of the matrix, threading an accumulator argument through the computation.
 The fold function takes the second argument, and applies the function f to it and the first element of the matrix.
 Then, it feeds this result into the function f along with the second element, and so on. It returns the final result.
 If the input function is f and the elements are i0...iN, then this function computes f (... (f s i0) i1 ...) iN.
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.mapi(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Double,System.Double}}},FSharp.Stats.Matrix{System.Double})">
<summary>
 Builds a new matrix whose elements are the result of row wise applying the given function on each element of a. The integer index
 passed to the function indicates the index (from 0) the of the element being transformed.
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.copy(FSharp.Stats.Matrix{System.Double})">
<summary>
 Builds a new matrix whose elements are identical to the elements of a.
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.map(Microsoft.FSharp.Core.FSharpFunc{System.Double,System.Double},FSharp.Stats.Matrix{System.Double})">
<summary>
 Builds a new matrix whose elements are the result of row wise applying the given function on each element of a.
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.existsi(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Double,System.Boolean}}},FSharp.Stats.Matrix{System.Double})">
<summary>
 Iterates the given Matrix row wise and applies function f element wise.
 The iteration stops and returns true if an element satisfies the condition or false when the end of
 the matrix is reached.
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.foralli(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Double,System.Boolean}}},FSharp.Stats.Matrix{System.Double})">
<summary>
 Iterates the given Matrix row wise and applies function f element wise.
 The iteration stops and returns false if an element fails the condition or true when the end of
 the matrix is reached.
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.exists(Microsoft.FSharp.Core.FSharpFunc{System.Double,System.Boolean},FSharp.Stats.Matrix{System.Double})">
<summary>
 Iterates the given Matrix row wise and applies function f element wise.
 The iteration stops and returns true if an element satisfies the condition or false when the end of
 the matrix is reached.
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.forall(Microsoft.FSharp.Core.FSharpFunc{System.Double,System.Boolean},FSharp.Stats.Matrix{System.Double})">
<summary>
 Iterates the given Matrix row wise and applies function f element wise.
 The iteration stops and returns false if an element fails the condition or true when the end of
 the matrix is reached.
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.transpose(FSharp.Stats.Matrix{System.Double})">
<summary>
 Returns the transpose of matrix a 
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.trace(FSharp.Stats.Matrix{System.Double})">
<summary>
 Computes the trace of matrix a by summing elements of the diagonal.
 Only usable if matrices a is a square matrix (m*m).
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.neg(FSharp.Stats.Matrix{System.Double})">
<summary>
 Scales matrix a by element wise mulitplication with minus 1.
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.scale(System.Double,FSharp.Stats.Matrix{System.Double})">
<summary>
 Builds a new matrix where the elements are the result of multiplying every element of the given matrix with the given value
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.cptMin(FSharp.Stats.Matrix{System.Double},FSharp.Stats.Matrix{System.Double})">
<summary>
 Performs a element wise comparison of matrices a and b always preserving the smaller value.
 Only usable if both matrices have the same dimensions.
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.cptMax(FSharp.Stats.Matrix{System.Double},FSharp.Stats.Matrix{System.Double})">
<summary>
 Performs a element wise comparison of matrices a and b always preserving the greater value.
 Only usable if both matrices have the same dimensions.
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.cptMul(FSharp.Stats.Matrix{System.Double},FSharp.Stats.Matrix{System.Double})">
<summary>
 Performs a element wise multiplication of matrices a and b (a+b, Hadamard-Product).
 Only usable if both matrices have the same dimensions.
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.mulRV(FSharp.Stats.RowVector{System.Double},FSharp.Stats.Matrix{System.Double})">
<summary>
 Performs a matrix multiplication of the 1*n rowvector a and the m*n matrix b (a*b).
 Only usable if column number (n) of the vector equals the row number (m) of the matrix.
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.mulV(FSharp.Stats.Matrix{System.Double},FSharp.Stats.Vector{System.Double})">
<summary>
 Performs a matrix multiplication m*n matrix a and the m*1 vector b (a*b).
 Only usable if column number (n) of the matrix equals the row number (m) of the vector.
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.mul(FSharp.Stats.Matrix{System.Double},FSharp.Stats.Matrix{System.Double})">
<summary>
 Performs a left sided matrix multiplication of a and b (a*b).
 Only usable if both matrices have the same dimensions.
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.sub(FSharp.Stats.Matrix{System.Double},FSharp.Stats.Matrix{System.Double})">
<summary>
 Performs a element wise substraction of matrices a and b (a-b).
 Only usable if both matrices have the same dimensions.
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.add(FSharp.Stats.Matrix{System.Double},FSharp.Stats.Matrix{System.Double})">
<summary>
 Performs a element wise addition of matrices a and b (a+b).
 Only usable if both matrices have the same dimensions.
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.Generic.flattenColWise``1(FSharp.Stats.Matrix{``0})">
<summary>
 Iterates the given Matrix column wise and places every element in a new vector with length n*m.
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.Generic.flattenRowWise``1(FSharp.Stats.Matrix{``0})">
<summary>
 Iterates the given Matrix row wise and places every element in a new vector with length n*m.
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.Generic.mapiCols``2(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{FSharp.Stats.Vector{``0},``1}},FSharp.Stats.Matrix{``0})">
<summary>
 Maps every matrix column using the position dependant function
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.Generic.enumerateColumnWise``2(Microsoft.FSharp.Core.FSharpFunc{System.Collections.Generic.IEnumerable{``0},``1},FSharp.Stats.Matrix{``0})">
<summary>
 Applies function f along colÃºmn axis 
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.Generic.mapiRows``2(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{FSharp.Stats.RowVector{``0},``1}},FSharp.Stats.Matrix{``0})">
<summary>
 Maps every matrix row using the position dependant function
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.Generic.enumerateRowWise``2(Microsoft.FSharp.Core.FSharpFunc{System.Collections.Generic.IEnumerable{``0},``1},FSharp.Stats.Matrix{``0})">
<summary>
 Applies function f along row axis 
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.Generic.toScalar``1(FSharp.Stats.Matrix{``0})">

</member>
<member name="M:FSharp.Stats.MatrixModule.Generic.toRowVector``1(FSharp.Stats.Matrix{``0})">

</member>
<member name="M:FSharp.Stats.MatrixModule.Generic.toVector``1(FSharp.Stats.Matrix{``0})">

</member>
<member name="M:FSharp.Stats.MatrixModule.Generic.ofVector``1(FSharp.Stats.Vector{``0})">

</member>
<member name="M:FSharp.Stats.MatrixModule.Generic.ofRowVector``1(FSharp.Stats.RowVector{``0})">

</member>
<member name="M:FSharp.Stats.MatrixModule.Generic.getRegion``1(FSharp.Stats.Matrix{``0},System.Int32,System.Int32,System.Int32,System.Int32)">

</member>
<member name="M:FSharp.Stats.MatrixModule.Generic.getRows``1(FSharp.Stats.Matrix{``0},System.Int32,System.Int32)">

</member>
<member name="M:FSharp.Stats.MatrixModule.Generic.getCols``1(FSharp.Stats.Matrix{``0},System.Int32,System.Int32)">

</member>
<member name="M:FSharp.Stats.MatrixModule.Generic.setCol``1(FSharp.Stats.Matrix{``0},System.Int32,FSharp.Stats.Vector{``0})">
<summary>
Replaces column of index i of matrix a with values of vector v, if vector length matches columnsize
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.Generic.getCol``1(FSharp.Stats.Matrix{``0},System.Int32)">
<summary>
Returns col of index j of matrix a
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.Generic.setRow``1(FSharp.Stats.Matrix{``0},System.Int32,FSharp.Stats.Vector{``0})">
<summary>
Replaces row of index j of matrix a with values of vector v, if vector length matches rowsize
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.Generic.getRow``1(FSharp.Stats.Matrix{``0},System.Int32)">
<summary>
Returns row of index i of matrix a
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.Generic.hash``1(FSharp.Stats.Matrix{``0})">

</member>
<member name="M:FSharp.Stats.MatrixModule.Generic.compare``1(FSharp.Stats.Matrix{``0},FSharp.Stats.Matrix{``0})">

</member>
<member name="M:FSharp.Stats.MatrixModule.Generic.foldi``2(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}}}},``0,FSharp.Stats.Matrix{``1})">

</member>
<member name="M:FSharp.Stats.MatrixModule.Generic.fold``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}},``0,FSharp.Stats.Matrix{``1})">

</member>
<member name="M:FSharp.Stats.MatrixModule.Generic.initSparse``1(System.Int32,System.Int32,System.Collections.Generic.IEnumerable{System.Tuple{System.Int32,System.Int32,``0}})">

</member>
<member name="M:FSharp.Stats.MatrixModule.Generic.initDense``1(System.Int32,System.Int32,System.Collections.Generic.IEnumerable{System.Tuple{System.Int32,System.Int32,``0}})">

</member>
<member name="M:FSharp.Stats.MatrixModule.Generic.toDense``1(FSharp.Stats.Matrix{``0})">

</member>
<member name="M:FSharp.Stats.MatrixModule.Generic.getDiag``1(FSharp.Stats.Matrix{``0})">

</member>
<member name="M:FSharp.Stats.MatrixModule.Generic.getDiagN``1(FSharp.Stats.Matrix{``0},System.Int32)">

</member>
<member name="M:FSharp.Stats.MatrixModule.Generic.mapi``1(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,``0}}},FSharp.Stats.Matrix{``0})">

</member>
<member name="M:FSharp.Stats.MatrixModule.Generic.copy``1(FSharp.Stats.Matrix{``0})">

</member>
<member name="M:FSharp.Stats.MatrixModule.Generic.map``1(Microsoft.FSharp.Core.FSharpFunc{``0,``0},FSharp.Stats.Matrix{``0})">

</member>
<member name="M:FSharp.Stats.MatrixModule.Generic.foralli``1(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean}}},FSharp.Stats.Matrix{``0})">
<summary>
 Iterates the given Matrix row wise and applies function f element wise.
 The iteration stops and returns false if an element fails the condition or true when the end of
 the matrix is reached.
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.Generic.existsi``1(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean}}},FSharp.Stats.Matrix{``0})">
<summary>
 Iterates the given Matrix row wise and applies function f element wise.
 The iteration stops and returns true if an element satisfies the condition or false when the end of
 the matrix is reached.
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.Generic.forall``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},FSharp.Stats.Matrix{``0})">
<summary>
 Iterates the given Matrix row wise and applies function f element wise.
 The iteration stops and returns false if an element fails the condition or true when the end of
 the matrix is reached.
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.Generic.exists``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},FSharp.Stats.Matrix{``0})">
<summary>
 Iterates the given Matrix row wise and applies function f element wise.
 The iteration stops and returns true if an element satisfies the condition or false when the end of
 the matrix is reached.
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.Generic.inplaceSub``1(FSharp.Stats.Matrix{``0},FSharp.Stats.Matrix{``0})">
<summary>
 Performs a element wise substraction of matrices a and b (a-b).
 Attention: the output overrides matrix a.
 Only usable if both matrices have the same dimensions.
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.Generic.inplaceAdd``1(FSharp.Stats.Matrix{``0},FSharp.Stats.Matrix{``0})">
<summary>
 Performs a element wise addition of matrices a and b (a+b).
 Attention: the output overrides matrix a.
 Only usable if both matrices have the same dimensions.        
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.Generic.transpose``1(FSharp.Stats.Matrix{``0})">
<summary>
 Returns the transpose of matrix a 
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.Generic.norm``1(FSharp.Stats.Matrix{``0})">

</member>
<member name="M:FSharp.Stats.MatrixModule.Generic.prod``1(FSharp.Stats.Matrix{``0})">
<summary>
 Computes the product of all matrix elements.
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.Generic.sum``1(FSharp.Stats.Matrix{``0})">
<summary>
 Computes the sum all elements matrix elements.
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.Generic.trace``1(FSharp.Stats.Matrix{``0})">
<summary>
 Computes the trace of matrix a by summing elements of the diagonal.
 Only usable if matrices a is a square matrix (m*m).
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.Generic.neg``1(FSharp.Stats.Matrix{``0})">
<summary>
 Scales matrix a by element wise mulitplication with minus 1.
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.Generic.dot``1(FSharp.Stats.Matrix{``0},FSharp.Stats.Matrix{``0})">
<summary>
 Performs a dot product of matrices a and b.
 Only usable if both matrices have the same dimensions.
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.Generic.scale``1(``0,FSharp.Stats.Matrix{``0})">
<summary>
 Builds a new matrix where the elements are the result of multiplying every element of the given matrix with the given value
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.Generic.cptMin``1(FSharp.Stats.Matrix{``0},FSharp.Stats.Matrix{``0})">
<summary>
 Performs a element wise comparison of matrices a and b always preserving the smaller value.
 Only usable if both matrices have the same dimensions.
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.Generic.cptMax``1(FSharp.Stats.Matrix{``0},FSharp.Stats.Matrix{``0})">
<summary>
 Performs a element wise comparison of matrices a and b always preserving the greater value.
 Only usable if both matrices have the same dimensions.
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.Generic.cptMul``1(FSharp.Stats.Matrix{``0},FSharp.Stats.Matrix{``0})">
<summary>
 Performs a element wise multiplication of matrices a and b (a*b, Hadamard-Product).
 Only usable if both matrices have the same dimensions.
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.Generic.mulV``1(FSharp.Stats.Matrix{``0},FSharp.Stats.Vector{``0})">
<summary>
 Performs a matrix multiplication m*n matrix a and the m*1 vector b (a*b).
 Only usable if column number (n) of the matrix equals the row number (m) of the vector.
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.Generic.mulRV``1(FSharp.Stats.RowVector{``0},FSharp.Stats.Matrix{``0})">
<summary>
 Performs a matrix multiplication of the 1*n rowvector a and the m*n matrix b (a*b).
 Only usable if column number (n) of the vector equals the row number (m) of the matrix.
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.Generic.mul``1(FSharp.Stats.Matrix{``0},FSharp.Stats.Matrix{``0})">
<summary>
 Performs a left sided matrix multiplication of a and b (a*b).
 Only usable if both matrices have the same dimensions.
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.Generic.sub``1(FSharp.Stats.Matrix{``0},FSharp.Stats.Matrix{``0})">
<summary>
 Performs a element wise substraction of matrices a and b (a-b).
 Only usable if both matrices have the same dimensions.
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.Generic.add``1(FSharp.Stats.Matrix{``0},FSharp.Stats.Matrix{``0})">
<summary>
 Performs a element wise addition of matrices a and b (a+b).
 Only usable if both matrices have the same dimensions.
</summary>
</member>
<member name="M:FSharp.Stats.Rank.rankAverage``1(``0[])">
<summary>
 Ranks each entry of the given unsorted data array.
 Ties are replaced by their mean
</summary>
</member>
<member name="M:FSharp.Stats.Rank.rankMax``1(``0[])">
<summary>
 Ranks each entry of the given unsorted data array.
 Ties are replaced by their maximum  
</summary>
</member>
<member name="M:FSharp.Stats.Rank.rankMin``1(``0[])">
<summary>
 Ranks each entry of the given unsorted data array.
 Ties are replaced by their minimum  
</summary>
</member>
<member name="M:FSharp.Stats.Rank.rankFirst``1(``0[])">
<summary>
 Ranks each entry of the given unsorted data array.
 Permutation with increasing values at each index of ties.
</summary>
</member>
<member name="M:FSharp.Stats.Rank.rank``2(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,``0}},Microsoft.FSharp.Core.FSharpFunc{System.Int32,``0},``1[])">
<summary>
 Ranks each entry of the given unsorted data array. Use &apos;breakTies function to break ties
</summary>
</member>
<member name="T:FSharp.Stats.Rank">
<summary>
 Module to Calculate the rank. The rank of a number is its size relative to other values in a sequence
</summary>
</member>
<member name="M:FSharp.Stats.Correlation.Matrix.rv2(FSharp.Stats.Matrix{System.Double},FSharp.Stats.Matrix{System.Double})">
<summary>
 Computes the rv2 coefficient.  
</summary>
</member>
<member name="M:FSharp.Stats.Correlation.Vector.xCorr(System.Int32,FSharp.Stats.Vector{System.Double},FSharp.Stats.Vector{System.Double})">
<summary>
 computes the unnormalized (using only the dot product) cross-correlation of signals v1 and v2 at a given lag.
</summary>
</member>
<member name="M:FSharp.Stats.Correlation.Vector.normalizedXCorr(System.Int32,FSharp.Stats.Vector{System.Double},FSharp.Stats.Vector{System.Double})">
<summary>
 computes the normalized (using pearson correlation) cross-correlation of signals v1 and v2 at a given lag.
</summary>
</member>
<member name="M:FSharp.Stats.Correlation.Vector.autoCovariance(System.Int32,FSharp.Stats.Vector{System.Double})">
<summary>
 computes the sample auto corvariance of a signal at a given lag.
</summary>
</member>
<member name="M:FSharp.Stats.Correlation.Vector.autoCorrelation(System.Int32,FSharp.Stats.Vector{System.Double})">
<summary>
 computes the sample auto correlation (using pearson correlation) of a signal at a given lag.
</summary>
</member>
<member name="M:FSharp.Stats.Correlation.Vector.correlationOf(Microsoft.FSharp.Core.FSharpFunc{FSharp.Stats.Vector{System.Double},Microsoft.FSharp.Core.FSharpFunc{FSharp.Stats.Vector{System.Double},System.Double}},System.Int32,FSharp.Stats.Vector{System.Double},FSharp.Stats.Vector{System.Double})">
<summary>
 computes the sample correlation of two signal at a given lag.
 was tested in comparison to: https://www.wessa.net/rwasp_autocorrelation.wasp
</summary>
</member>
<member name="M:FSharp.Stats.Correlation.Seq.kendall``2(``0[],``1[])">
<summary>
 Kendall Correlation Coefficient 
</summary>
</member>
<member name="M:FSharp.Stats.Correlation.Seq.spearman``2(``0[],``1[])">
<summary>
 Spearman Correlation (with ranks)
</summary>
</member>
<member name="M:FSharp.Stats.Correlation.Seq.pearson``3(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
<summary>
 Pearson correlation 
</summary>
</member>
<member name="M:FSharp.Stats.Quantile.computePercentiles``1(Microsoft.FSharp.Core.FSharpFunc{System.Double,Microsoft.FSharp.Core.FSharpFunc{System.Double[],``0}},System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Double})">
<summary>
 Computes percentiles
 percentiles: Each percentile must be between 0.0 and 1.0 (inclusive)
 CalcMethod should be ofSorted array
</summary>
</member>
<member name="M:FSharp.Stats.Quantile.interQuantileRange``1(Microsoft.FSharp.Core.FSharpFunc{System.Double,Microsoft.FSharp.Core.FSharpFunc{``0[],System.Double}},``0[])">
<summary>
 Computes the interquartile range (IQR)
</summary>
</member>
<member name="M:FSharp.Stats.Quantile.normal(System.Double,System.Double[])">
<summary>
 Estimates the q-th quantile from the unsorted data array.
</summary>
</member>
<member name="M:FSharp.Stats.Quantile.mode(System.Double,System.Double[])">
<summary>
 Estimates the q-th quantile from the unsorted data array.
 R! default
</summary>
</member>
<member name="M:FSharp.Stats.Quantile.nist(System.Double,System.Double[])">
<summary>
 Estimates the q-th quantile from the unsorted data array.
</summary>
</member>
<member name="M:FSharp.Stats.Quantile.hazen(System.Double,System.Double[])">
<summary>
 Estimates the q-th quantile from the unsorted data array.
</summary>
</member>
<member name="M:FSharp.Stats.Quantile.california(System.Double,System.Double[])">
<summary>
 Estimates the q-th quantile from the unsorted data array.
</summary>
</member>
<member name="M:FSharp.Stats.Quantile.nearest(System.Double,System.Double[])">
<summary>
 Estimates the q-th quantile from the unsorted data array.
</summary>
</member>
<member name="M:FSharp.Stats.Quantile.empiricalInvCdfAverage(System.Double,System.Double[])">
<summary>
 Estimates the q-th quantile from the unsorted data array.
</summary>
</member>
<member name="M:FSharp.Stats.Quantile.empiricalInvCdf(System.Double,System.Double[])">
<summary>
 Estimates the q-th quantile from the unsorted data array.
</summary>
</member>
<member name="M:FSharp.Stats.Quantile.compute(System.Double,System.Double[])">
<summary>
 Estimates the q-th quantile from the unsorted data array.
 Approximately median-unbiased regardless of the sample distribution.
</summary>
</member>
<member name="M:FSharp.Stats.Quantile.OfSorted.normal(System.Double,System.Double[])">
<summary>
 Estimates the q-th quantile from the unsorted data array. (in place)
</summary>
</member>
<member name="M:FSharp.Stats.Quantile.OfSorted.mode(System.Double,System.Double[])">
<summary>
 Estimates the q-th quantile from the unsorted data array. (in place)
</summary>
</member>
<member name="M:FSharp.Stats.Quantile.OfSorted.nist(System.Double,System.Double[])">
<summary>
 Estimates the q-th quantile from the unsorted data array. (in place)
</summary>
</member>
<member name="M:FSharp.Stats.Quantile.OfSorted.hazen(System.Double,System.Double[])">
<summary>
 Estimates the q-th quantile from the unsorted data array. (in place)
</summary>
</member>
<member name="M:FSharp.Stats.Quantile.OfSorted.california(System.Double,System.Double[])">
<summary>
 Estimates the q-th quantile from the unsorted data array. (in place)
</summary>
</member>
<member name="M:FSharp.Stats.Quantile.OfSorted.nearest(System.Double,System.Double[])">
<summary>
 Estimates the q-th quantile from the unsorted data array. (in place)
</summary>
</member>
<member name="M:FSharp.Stats.Quantile.OfSorted.empiricalInvCdfAverage(System.Double,System.Double[])">
<summary>
 Estimates the q-th quantile from the unsorted data array. (in place)
</summary>
</member>
<member name="M:FSharp.Stats.Quantile.OfSorted.empiricalInvCdf(System.Double,System.Double[])">
<summary>
 Estimates the q-th quantile from the unsorted data array. (in place)
</summary>
</member>
<member name="M:FSharp.Stats.Quantile.OfSorted.compute(System.Double,System.Double[])">
<summary>
 Estimates the q-th quantile from the unsorted data array. (in place)
 Approximately median-unbiased regardless of the sample distribution.
</summary>
</member>
<member name="T:FSharp.Stats.Quantile.OfSorted">
<summary>
 ! Input needs to be sorted
</summary>
</member>
<member name="M:FSharp.Stats.Quantile.InPlace.normalInPLace(System.Double,System.Double[])">
<summary>
 Estimates the q-th quantile from the unsorted data array. (in place)
</summary>
</member>
<member name="M:FSharp.Stats.Quantile.InPlace.modeInPLace(System.Double,System.Double[])">
<summary>
 Estimates the q-th quantile from the unsorted data array. (in place)
</summary>
</member>
<member name="M:FSharp.Stats.Quantile.InPlace.nistInPLace(System.Double,System.Double[])">
<summary>
 Estimates the q-th quantile from the unsorted data array. (in place)
</summary>
</member>
<member name="M:FSharp.Stats.Quantile.InPlace.hazenInPLace(System.Double,System.Double[])">
<summary>
 Estimates the q-th quantile from the unsorted data array. (in place)
</summary>
</member>
<member name="M:FSharp.Stats.Quantile.InPlace.californiaInPLace(System.Double,System.Double[])">
<summary>
 Estimates the q-th quantile from the unsorted data array. (in place)
</summary>
</member>
<member name="M:FSharp.Stats.Quantile.InPlace.nearestInPLace(System.Double,System.Double[])">
<summary>
 Estimates the q-th quantile from the unsorted data array. (in place)
</summary>
</member>
<member name="M:FSharp.Stats.Quantile.InPlace.empiricalInvCdfAverageInPLace(System.Double,System.Double[])">
<summary>
 Estimates the q-th quantile from the unsorted data array. (in place)
</summary>
</member>
<member name="M:FSharp.Stats.Quantile.InPlace.empiricalInvCdfInPLace(System.Double,System.Double[])">
<summary>
 Estimates the q-th quantile from the unsorted data array. (in place)
</summary>
</member>
<member name="M:FSharp.Stats.Quantile.InPlace.computeInplace(System.Double,System.Double[])">
<summary>
 Estimates the q-th quantile from the unsorted data array. (in place)
 Approximately median-unbiased regardless of the sample distribution.
</summary>
</member>
<member name="T:FSharp.Stats.Quantile.InPlace">
<summary>
 ! Works inplace and can thus causes the data array to be reordered
</summary>
</member>
<member name="T:FSharp.Stats.Quantile">
<summary>
 Module to estimate different quantile measures
</summary>
</member>
<member name="M:FSharp.Stats.Precision.almostEqualNorm(System.Double,System.Double)">
<summary>
 Compares two float values and determines if they differ by no more than 10.*(2.**(-52.).
</summary>
</member>
<member name="M:FSharp.Stats.Precision.almostEqualNormRelative(System.Double,System.Double,System.Double)">
<summary>
 Compares two float values and determines if they differ by no more than specified by the maximum error.
</summary>
</member>
<member name="T:FSharp.Stats.Precision">
<summary>
 Module to estimate different quantile measures
</summary>
</member>
<member name="M:FSharp.Stats.SpecialFunctions.Gamma.upperIncomplete(System.Double,System.Double)">
<summary>
 Returns the incomplete gamma function Q(a,X) = 1 - P(a,X) (regularized gamma) 
</summary>
</member>
<member name="M:FSharp.Stats.SpecialFunctions.Gamma.lowerIncomplete(System.Double,System.Double)">
<summary>
 Returns the incomplete gamma function P(a,X) (regularized gamma) 
</summary>
</member>
<member name="M:FSharp.Stats.SpecialFunctions.Gamma.gammaLn(System.Double)">
<summary>
 Computes the log gamma function using the Lanczos Coefficients described in Numerical Recipes (Press et al)
</summary>
</member>
<member name="M:FSharp.Stats.SpecialFunctions.Gamma.gamma(System.Double)">
<summary>
 Computes the gamma function using the Lanczos Coefficients described in Numerical Recipes (Press et al) 
</summary>
</member>
<member name="T:FSharp.Stats.SpecialFunctions.Gamma">
<summary>
 Special mathematical functions
</summary>
</member>
<member name="M:FSharp.Stats.SpecialFunctions.Factorial.factorialLn(System.Int32)">
<summary>
 Computes the natural logarithm of the factorial function.
</summary>
</member>
<member name="M:FSharp.Stats.SpecialFunctions.Factorial.factorial(System.Int32)">
<summary>
 The factorial functions takes an int x and computes x!. This function will not overflow
 the floating point format as long as x is at most 170.
</summary>
</member>
<member name="T:FSharp.Stats.SpecialFunctions.Factorial">
<summary>
 Special mathematical functions
</summary>
</member>
<member name="M:FSharp.Stats.SpecialFunctions.Beta.lowerIncomplete(System.Double,System.Double,System.Double)">
<summary>
 Returns the regularized lower incomplete beta function
</summary>
</member>
<member name="M:FSharp.Stats.SpecialFunctions.Beta.beta(System.Double,System.Double)">
<summary>
 Computes the beta function.
</summary>
</member>
<member name="M:FSharp.Stats.SpecialFunctions.Beta.betaLn(System.Double,System.Double)">
<summary>
 Computes the natural logarithm of the beta function.
</summary>
</member>
<member name="T:FSharp.Stats.SpecialFunctions.Beta">
<summary>
 Special mathematical functions
</summary>
</member>
<member name="M:FSharp.Stats.SpecialFunctions.Errorfunction.Erfc(System.Double)">
<summary>
 Computes the complement of the error function. Note that this implementation has only been verified to have a relative error of around 1e-4.
</summary>
</member>
<member name="T:FSharp.Stats.SpecialFunctions.Errorfunction">
<summary>
 Special mathematical functions
</summary>
</member>
<member name="T:FSharp.Stats.SpecialFunctions.Logistic">
<summary>
 Special mathematical functions
</summary>
</member>
<member name="T:FSharp.Stats.SpecialFunctions.Binomial">
<summary>
 Special mathematical functions
</summary>
</member>
<member name="T:FSharp.Stats.LapackMKLStubs">
<summary>
 Warning:
 IMPORTANT WARNING NOTICE:
 INTEL MATH KERNEL LIBRARY 9.1 FOR WINDOWS IS THIRD PARTY TECHNOLOGY.
 IT IS CLEARED ONLY FOR USE BY A SPECIFIC MSR RESEARCH TEAM.
 DO NOT USE IT UNTIL YOU HAVE CLEARED ITS USE FOR YOUR PROJECT WITH YOUR LEGAL CONTACT.
 
 The following stubs bind directly to Intel MKL functionality.
 You should not use them without:
 a) Intel MKL developer licenses.
 b) Seeking local legal approval.
</summary>
</member>
<member name="M:FSharp.Stats.Algebra.ILinearAlgebra.dgesdd_thin_(FSharp.Stats.Matrix{System.Double})">
<summary>
Returns the thin Singular Value Decomposition of the input MxN matrix A 

A = U * SIGMA * V**T in the tuple (S, U, V**T), 

where S is an array containing the diagonal elements of SIGMA.
The first min(M,N) columns of U and the first min(M,N) rows of V**T are returned in the arrays U and VT;
uses the LAPACK routine dgesdd with the argument JOBZ = &apos;S&apos;
</summary>
</member>
<member name="M:FSharp.Stats.Algebra.ILinearAlgebra.dgesdd_(FSharp.Stats.Matrix{System.Double})">
<summary>
Returns the full Singular Value Decomposition of the input MxN matrix 

A : A = U * SIGMA * V**T in the tuple (S, U, V**T), 

where S is an array containing the diagonal elements of SIGMA.
uses the LAPACK routine dgesdd with the argument JOBZ = &apos;A&apos;
</summary>
</member>
<member name="T:FSharp.Stats.Algebra.ILinearAlgebra">
<summary>
This is an internal interface and not for user usage.
It exposes a specialised subset of BLAS/LAPACK functionality.
This functionality is used by us to build the exposed APIs.
It is those exposed APIs that should be used.
</summary>
</member>
<member name="M:FSharp.Stats.Algebra.LinearAlgebraManaged.pseudoInvers(FSharp.Stats.Matrix{System.Double})">
<summary>
 Calculates the pseudo inverse of the matrix
</summary>
</member>
<member name="M:FSharp.Stats.Algebra.LinearAlgebraManaged.leverage(FSharp.Stats.Matrix{System.Double})">
<summary>
 computes the leverage directly by QR decomposition of the designmatrix used in ordinary least squares approaches
 and computing of the diagnonal entries of the Hat matrix, known as the leverages of the regressors
</summary>
</member>
<member name="M:FSharp.Stats.Algebra.LinearAlgebraManaged.leverageBy(FSharp.Stats.Matrix{System.Double})">
<summary>
 computes the leverages of every dataPoint of a dataSet given by the diagonal of the hat matrix. 
</summary>
</member>
<member name="M:FSharp.Stats.Algebra.LinearAlgebraManaged.hatMatrix(FSharp.Stats.Matrix{System.Double})">
<summary>
 computes the hat matrix by the QR decomposition of the designmatrix used in ordinary least squares approaches
</summary>
</member>
<member name="M:FSharp.Stats.Algebra.LinearAlgebraManaged.HouseholderTransform(FSharp.Stats.Matrix{System.Double},System.Int32)">
<summary>
 This method computes and performs a Householder reflection. It will change the
 input matrix and return the reflection vector.
</summary>
</member>
<member name="M:FSharp.Stats.Algebra.LinearAlgebraManaged.sign(System.Double)">
<summary>
 Computes the sign of a floating point number.
</summary>
</member>
<member name="M:FSharp.Stats.Algebra.LinearAlgebraManaged.unitV(System.Int32)">
<summary>
 Generates a unit vector [1 0 .. 0 ].
</summary>
</member>
<member name="M:FSharp.Stats.Algebra.LinearAlgebraManaged.SolveLinearSystems(FSharp.Stats.Matrix{System.Double},FSharp.Stats.Matrix{System.Double})">
<summary>
 Solves a system of linear equations, Ax = b, with A LU factorized.        
</summary>
</member>
<member name="M:FSharp.Stats.Algebra.LinearAlgebraManaged.SolveLinearSystem(FSharp.Stats.Matrix{System.Double},FSharp.Stats.Vector{System.Double})">
<summary>
 Solves a system of linear equations, AX = B, with A LU factorized.
</summary>
</member>
<member name="M:FSharp.Stats.Algebra.LinearAlgebraManaged.LU(FSharp.Stats.Matrix{System.Double})">
<summary>
 For a matrix A, the LU factorization is a pair of lower triangular matrix L and upper triangular matrix U so that A = L*U.
 The pivot function encode a permutation operation such for a matrix P P*A = L*U.
</summary>
</member>
<member name="T:FSharp.Stats.Algebra.LinearAlgebraManaged">
<summary>
 This module is for internal use only.
</summary>
</member>
<member name="M:FSharp.Stats.Algebra.LinearAlgebra.Determinant(FSharp.Stats.Matrix{System.Double})">
<summary>
 Compute the determinant of a matrix by performing an LU decomposition since if A = P&apos;LU,
 then det(A) = det(P&apos;) * det(L) * det(U).
</summary>
</member>
<member name="M:FSharp.Stats.Algebra.LinearAlgebra.leverage(FSharp.Stats.Matrix{System.Double})">
<summary>
 computes the leverage directly by QR decomposition of the designmatrix used in ordinary least squares approaches
 and computing of the diagnonal entries of the Hat matrix, known as the leverages of the regressors
</summary>
</member>
<member name="M:FSharp.Stats.Algebra.LinearAlgebra.leverageBy(FSharp.Stats.Matrix{System.Double})">
<summary>
 computes the hat matrix by the QR decomposition of the designmatrix used in ordinary least squares approaches
</summary>
</member>
<member name="M:FSharp.Stats.Algebra.LinearAlgebra.hatmatrix(FSharp.Stats.Matrix{System.Double})">
<summary>
 computes the hat matrix by the QR decomposition of the designmatrix used in ordinary least squares approaches
</summary>
</member>
<member name="M:FSharp.Stats.Algebra.LinearAlgebra.thinSVD(FSharp.Stats.Matrix{System.Double})">
<summary>
Returns the thin Singular Value Decomposition of the input MxN matrix A 

A = U * SIGMA * V**T in the tuple (S, U, V**T), 

where S is an array containing the diagonal elements of SIGMA.
The first min(M,N) columns of U and the first min(M,N) rows of V**T are returned in the arrays U and VT;
uses the LAPACK routine dgesdd with the argument JOBZ = &apos;S&apos;
</summary>
</member>
<member name="M:FSharp.Stats.Algebra.LinearAlgebra.SVD(FSharp.Stats.Matrix{System.Double})">
<summary>
Returns the full Singular Value Decomposition of the input MxN matrix 

A : A = U * SIGMA * V**T in the tuple (S, U, V**T), 

where S is an array containing the diagonal elements of SIGMA.
uses the LAPACK routine dgesdd with the argument JOBZ = &apos;A&apos;
</summary>
</member>
<member name="M:FSharp.Stats.Algebra.LinearAlgebra.QR(FSharp.Stats.Matrix{System.Double})">
<summary>
 Given A[m,n] finds Q[m,m] and R[k,n] where k = min m n.
 Have A = Q.R  when m&lt;=n.
 Have A = Q.RX when m&gt;n and RX[m,n] is R[n,n] row extended with (m-n) zero rows.
</summary>
</member>
<member name="M:FSharp.Stats.Algebra.LinearAlgebra.LU(FSharp.Stats.Matrix{System.Double})">
<summary>
 Given A[n,n] real matrix.
 Finds P,L,U such that L*U = P*A with L,U lower/upper triangular.
</summary>
</member>
<member name="M:FSharp.Stats.Algebra.LinearAlgebra.Cholesky(FSharp.Stats.Matrix{System.Double})">
<summary>
 Given A[n,n] real symmetric positive definite.
 Finds the cholesky decomposition L such that L&apos; * L = A.
 May fail if not positive definite.
</summary>
</member>
<member name="M:FSharp.Stats.Algebra.LinearAlgebra.LeastSquares(FSharp.Stats.Matrix{System.Double},FSharp.Stats.Vector{System.Double})">
<summary>
 Given A[m,n] and B[m] solves AX = B for X[n].
 When m=&gt;n, have over constrained system, finds least squares solution for X.
 When m&lt;n, have under constrained system, finds least norm solution for X.
</summary>
</member>
<member name="M:FSharp.Stats.Algebra.LinearAlgebra.Inverse(FSharp.Stats.Matrix{System.Double})">
<summary>
 Given A[n,n] find it&apos;s inverse.
 This call may fail.
</summary>
</member>
<member name="M:FSharp.Stats.Algebra.LinearAlgebra.EigenSpectrumWhenSymmetric``2(``0)">
<summary>
 Compute eigenvalues and eigenvectors for a real symmetric matrix.
 Returns arrays of the values and vectors (both based on reals).
 This call may fail.
</summary>
</member>
<member name="M:FSharp.Stats.Algebra.LinearAlgebra.EigenValuesWhenSymmetric``2(``0)">
<summary>
 Compute eigenvalues for a real symmetric matrix.
 Returns array of real eigenvalues.
 This call may fail.
</summary>
</member>
<member name="M:FSharp.Stats.Algebra.LinearAlgebra.EigenValues``2(``0)">
<summary>
 Compute eigenvalues of a square real matrix.
 Returns arrays containing the eigenvalues which may be complex.
 This call may fail.
</summary>
</member>
<member name="M:FSharp.Stats.Algebra.LinearAlgebra.EVD``2(``0)">
<summary>
Compoutes for an N-by-N real nonsymmetric matrix A, the
eigenvalue decomposition eigenvalues and right eigenvectors.
The right eigenvector v(j) of A satisfies

                 A * v(j) = lambda(j) * v(j)

where lambda(j) is its eigenvalue.
The computed eigenvectors are normalized to have Euclidean norm
equal to 1 and largest component real. Uses the LAPACK subroutine dgeev with arguments JOBVR = &apos;V&apos; and JOBVL = &apos;N&apos;

Returns the real (first array) and imaginary (second array) parts of the eigenvalues and a matrix containing the corresponding eigenvectors
</summary>
</member>
<member name="M:FSharp.Stats.Algebra.LinearAlgebra.preDivideByMatrix(FSharp.Stats.Matrix{System.Double},FSharp.Stats.Matrix{System.Double})">
<summary>
 Given A[n,m] and B[n,k] solve for X[m,k] such that AX = B
 This call may fail.
</summary>
</member>
<member name="M:FSharp.Stats.Algebra.LinearAlgebra.preDivideByVector(FSharp.Stats.Matrix{System.Double},FSharp.Stats.Vector{System.Double})">
<summary>
 Given A[n,m] and B[n] solve for x[m] such that Ax = B
 This call may fail.
</summary>
</member>
<member name="M:FSharp.Stats.Rootfinding.Brent.tryFindRoot(Microsoft.FSharp.Core.FSharpFunc{System.Double,System.Double},System.Double,System.Double)">
<summary>
 accuracy is not sufficient to reach a root 
</summary>
</member>
<member name="M:FSharp.Stats.Rootfinding.Brent.tryFindRootWith(System.Double,System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Double,System.Double},System.Double,System.Double)">

</member>
<member name="M:FSharp.Stats.Rootfinding.Brent.updateBounds``2(Microsoft.FSharp.Core.FSharpFunc{System.Double,``0},System.Double,System.Double,``1,System.Double,System.Double)">

</member>
<member name="M:FSharp.Stats.Rootfinding.Brent.attemptInverseQuadraticInterpolation``1(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,``0,System.Double,System.Double)">

</member>
<member name="M:FSharp.Stats.Rootfinding.Brent.acceptBisection``2(``0,``1)">

</member>
<member name="M:FSharp.Stats.Rootfinding.Brent.acceptInterPolation``1(``0,System.Double,System.Double)">

</member>
<member name="M:FSharp.Stats.Rootfinding.Brent.checkConvergence(System.Double,System.Double,System.Double,System.Double,System.Double)">

</member>
<member name="M:FSharp.Stats.Rootfinding.Brent.adjustBounds(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">

</member>
<member name="M:FSharp.Stats.Integration.Differentiation.differentiateThreePoint(System.Double[],System.Double[],System.Int32,System.Int32,System.Int32,System.Int32)">
<summary>
 Three-Point Differentiation Helper.
 xValues Sample Points t.
 yValues Sample Values x(t)
 idxT Index of the point of the differentiation.&lt;/param&gt;
 idx0 Index of the first sample.&lt;/param&gt;
 idx1 Index of the second sample.&lt;/param&gt;
 idx2 Index of the third sample.&lt;/param&gt;
</summary>
</member>
<member name="M:FSharp.Stats.Optimization.Bisection.tryFindRoot(Microsoft.FSharp.Core.FSharpFunc{System.Double,System.Double},System.Double,System.Double,System.Double,System.Int32)">
<summary>
Finds the value in an interval for which a given function returns a value close to 0 
</summary>
</member>
<member name="P:FSharp.Stats.Interpolation.LinearSpline.LinearSplineCoef.C1">
<summary>
 First order spline coefficients (N)
</summary>
</member>
<member name="P:FSharp.Stats.Interpolation.LinearSpline.LinearSplineCoef.C0">
<summary>
 Zero order spline coefficients (N)
</summary>
</member>
<member name="P:FSharp.Stats.Interpolation.LinearSpline.LinearSplineCoef.XValues">
<summary>
 sample points (N+1), sorted ascending
</summary>
</member>
<member name="M:FSharp.Stats.Interpolation.LinearSpline.differentiate(FSharp.Stats.Interpolation.LinearSpline.LinearSplineCoef,System.Double)">
<summary>
 Differentiate at point x
</summary>
</member>
<member name="M:FSharp.Stats.Interpolation.LinearSpline.interpolate(FSharp.Stats.Interpolation.LinearSpline.LinearSplineCoef,System.Double)">
<summary>
 Interpolate at point x
</summary>
</member>
<member name="M:FSharp.Stats.Interpolation.LinearSpline.initInterpolate(System.Double[],System.Double[])">
<summary>
 Returns the linear spline interpolation coefficients from unsorted x,y data     
</summary>
</member>
<member name="M:FSharp.Stats.Interpolation.LinearSpline.initInterpolateInplace(System.Double[],System.Double[])">
<summary>
 Returns the linear spline interpolation coefficients from unsorted x,y data 
 Works in place
</summary>
</member>
<member name="M:FSharp.Stats.Interpolation.LinearSpline.initInterpolateSorted(System.Double[],System.Double[])">
<summary>
 Returns the linear spline interpolation coefficients from sorted x,y data
</summary>
</member>
<member name="M:FSharp.Stats.Interpolation.LinearSpline.createLinearSplineCoef(System.Double[],System.Double[],System.Double[])">

</member>
<member name="P:FSharp.Stats.Interpolation.CubicSpline.SplineCoefficients.C3">
<summary>
 Third order spline coefficients (N)
</summary>
</member>
<member name="P:FSharp.Stats.Interpolation.CubicSpline.SplineCoefficients.C2">
<summary>
 Second order spline coefficients (N)
</summary>
</member>
<member name="P:FSharp.Stats.Interpolation.CubicSpline.SplineCoefficients.C1">
<summary>
 First order spline coefficients (N)
</summary>
</member>
<member name="P:FSharp.Stats.Interpolation.CubicSpline.SplineCoefficients.C0">
<summary>
 Zero order spline coefficients (N)
</summary>
</member>
<member name="P:FSharp.Stats.Interpolation.CubicSpline.SplineCoefficients.XValues">
<summary>
 sample points (N+1), sorted ascending
</summary>
</member>
<member name="M:FSharp.Stats.Interpolation.CubicSpline.definiteIntegral(Microsoft.FSharp.Core.FSharpFunc{System.Double,System.Double},System.Double,System.Double)">

</member>
<member name="M:FSharp.Stats.Interpolation.CubicSpline.integrate(FSharp.Stats.Interpolation.CubicSpline.SplineCoefficients,System.Double)">

</member>
<member name="M:FSharp.Stats.Interpolation.CubicSpline.computeIndefiniteIntegral(FSharp.Stats.Interpolation.CubicSpline.SplineCoefficients)">

</member>
<member name="M:FSharp.Stats.Interpolation.CubicSpline.secondDerivative(FSharp.Stats.Interpolation.CubicSpline.SplineCoefficients,System.Double)">

</member>
<member name="M:FSharp.Stats.Interpolation.CubicSpline.firstDerivative(FSharp.Stats.Interpolation.CubicSpline.SplineCoefficients,System.Double)">

</member>
<member name="M:FSharp.Stats.Interpolation.CubicSpline.interpolateAtX(FSharp.Stats.Interpolation.CubicSpline.SplineCoefficients,System.Double)">

</member>
<member name="M:FSharp.Stats.Interpolation.CubicSpline.akimaCoefficients(System.Double[],System.Double[])">

</member>
<member name="M:FSharp.Stats.Interpolation.CubicSpline.leftSegmentIdx``1(``0[],``0)">

</member>
<member name="M:FSharp.Stats.Interpolation.CubicSpline.interpolateHermiteSorted(System.Double[],System.Double[],System.Double[])">

</member>
<member name="M:FSharp.Stats.Interpolation.CubicSpline.createSplineCoefficients(System.Double[],System.Double[],System.Double[],System.Double[],System.Double[])">

</member>
<member name="M:FSharp.Stats.Interpolation.Approximation.approx(System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Double},Microsoft.FSharp.Core.FSharpFunc{System.Collections.Generic.IEnumerable{System.Double},System.Double})">
<summary>
 Return a sequence of points which linearly interpolate given data points, or a function performing the linear interpolation.
</summary>
</member>
<member name="M:FSharp.Stats.Interpolation.Approximation.regularizeValues(System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Double},Microsoft.FSharp.Core.FSharpFunc{System.Collections.Generic.IEnumerable{System.Double},System.Double})">
<summary>
 Regularize (like R! regularize.values) used in approx
 1. pairs x -y values 
 2. filters nan on both sides and sortby x
 3. handels ties by given function
</summary>
</member>
<member name="M:FSharp.Stats.Signal.FFT.inverseSymmetricScalingInPlace(System.Double[])">
<summary>
 Universal; Symmetric scaling and common exponent (used in Maple) Default
</summary>
</member>
<member name="M:FSharp.Stats.Signal.FFT.inverseAsymmetricScalingInPlace(System.Double[])">
<summary>
 Only scale by 1/N in the inverse direction; No scaling in forward direction.
</summary>
</member>
<member name="M:FSharp.Stats.Signal.FFT.symmetricScalingInPlace(System.Double[])">
<summary>
 Universal; Symmetric scaling and common exponent (used in Maple) Default InverseExponent
</summary>
</member>
<member name="M:FSharp.Stats.Signal.FFT.asymmetricScalingInPlace(System.Double[])">
<summary>
 No scaling in forward direction.
</summary>
</member>
<member name="M:FSharp.Stats.Signal.FFT.bluestein(FSharp.Stats.Complex[])">
<summary>
 Bluesteinï¿½s convolution algorith
</summary>
</member>
<member name="M:FSharp.Stats.Signal.FFT.bitrev``1(``0[])">
<summary>
 Reorder the elements of the input array in lexicographic order by the bits of their indices
</summary>
</member>
<member name="M:FSharp.Stats.Signal.FFT.mapInPlace``1(Microsoft.FSharp.Core.FSharpFunc{``0,``0},``0[])">
<summary>
 Applying the given function to each of the elements of the array and returns the value in place.
</summary>
</member>
<member name="T:FSharp.Stats.Signal.FFT">
<summary>
 FFT analysis converts a signal from its original domain (often time or space) to a representation in the frequency domain and vice versa.
</summary>
</member>
<member name="M:FSharp.Stats.Signal.Baseline.baselineAls(System.Int32,System.Int32,System.Double,System.Double[])">
<summary>
 Asymmetric Least Squares Smoothing by P. Eilers and H. Boelens in 2005
</summary>
</member>
<member name="M:FSharp.Stats.Signal.Baseline.diff(System.Int32,System.Double[0:, 0:])">
<summary>
 Calculate the n-th order discrete difference along given axis.
</summary>
</member>
<member name="M:FSharp.Stats.Signal.Baseline.diag``1(System.Int32,``0)">
<summary>
 Creates a diagonal 2-D array with the given order and set all diagonal values to x
</summary>
</member>
<member name="M:FSharp.Stats.Signal.Filtering.savitzky_golay(System.Int32,System.Int32,System.Int32,System.Int32,System.Double[])">
<summary>
 Smooth (and optionally differentiate) data with a Savitzky-Golay filter.
 The Savitzky-Golay filter is a type of low-pass filter and removes high frequency noise from data.
</summary>
</member>
<member name="M:FSharp.Stats.Signal.Convolution.convolve(FSharp.Stats.Vector{System.Double},FSharp.Stats.Vector{System.Double})">
<summary>
 Computes a complete non-circular convolution of x and y. This function does not use
 the fast fourier transformation to calculate the convolution and can be slow if x and y are large.
 This function does not perform a padding of x and y. 
</summary>
</member>
<member name="T:FSharp.Stats.Distributions.Distribution`2">
<summary>
 Interface which every probability distribution must implement.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Bandwidth.uLSCV(System.Double[],Microsoft.FSharp.Core.FSharpOption{System.Int32})">
<summary>
 Least squares cross-validation of bandwidth (unbiased)
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Bandwidth.nrd0(System.Double[])">
<summary>
 Implements Silverman&apos;s ârule of thumbâ for choosing the bandwidth of a Gaussian kernel density estimator.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Bandwidth.freedmanDiaconis(System.Double[])">
<summary>
 Calcultes bandwidth based on the FreedmanâDiaconis rule
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Bandwidth.scottNormal(System.Double[])">
<summary>
 Calcultes bandwidth according to Scott&apos;s normal reference rule
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Bandwidth.forHistogram(System.Collections.Generic.IEnumerable{System.Double})">
<summary>
 Simple bandwidth for histogram
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Bandwidth.fromBinNumber``3(``0,``1,``2)">
<summary>
 Calculates the bandwidth from min max and number of bins
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Bandwidth.BinNumber.riceRule(System.Double)">
<summary>
The Rice Rule is presented as a simple alternative to Sturges&apos;s rule.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Bandwidth.BinNumber.sturges(System.Double)">
<summary>
 Sturges&apos; formula is derived from a binomial distribution and implicitly assumes an approximately normal distribution.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Bandwidth.BinNumber.sqrt(System.Double)">
<summary>
 Square-root choice
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Bandwidth.BinNumber.fromBandwidth(System.Double,System.Double,System.Double)">
<summary>
 Compute the number of bins from bandwidth
</summary>
</member>
<member name="T:FSharp.Stats.Distributions.Bandwidth.BinNumber">
<summary>
 Compute the number of bins for a histogram
</summary>
</member>
<member name="T:FSharp.Stats.Distributions.Bandwidth">
<summary>
 Bandwidth selectors 
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Frequency.isSubset(Microsoft.FSharp.Collections.FSharpMap{System.Double,System.Int32},Microsoft.FSharp.Collections.FSharpMap{System.Double,System.Int32})">
<summary>
 Checks whether the values in this histogram A are a subset of the values in the histogram B
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Frequency.frequencies(Microsoft.FSharp.Collections.FSharpMap{System.Double,System.Int32})">
<summary>
 Gets an unsorted sequence of frequencies
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Frequency.frequencyAt(Microsoft.FSharp.Collections.FSharpMap{System.Double,System.Int32},System.Double)">
<summary>
 Gets the frequency associated with the value x
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Frequency.maxLike(Microsoft.FSharp.Collections.FSharpMap{System.Double,System.Int32})">
<summary>
 Gets the largest frequency in the map.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Frequency.average(Microsoft.FSharp.Collections.FSharpMap{System.Double,System.Int32})">
<summary>
 Returns the average of the frequencies in the map
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Frequency.sum(Microsoft.FSharp.Collections.FSharpMap{System.Double,System.Int32})">
<summary>
 Returns the total of the frequencies in the map
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Frequency.getZip(Microsoft.FSharp.Collections.FSharpMap{System.Double,System.Int32})">
<summary>
 Returns tuple of (sorted value sequence, frequence sequence)
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Frequency.create(System.Double,System.Collections.Generic.IEnumerable{System.Double})">
<summary>
 Creates probability mass function (histogram)    
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Frequency.createGeneric``1(Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Given the list [a,b,a,c,b,b], produce a map {a:2, b:3, c:1} which contains the count of each unique item in the list
</summary>
</member>
<member name="T:FSharp.Stats.Distributions.Frequency">
<summary>
 Represents a histogram (map from values to integer frequencies).
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Empirical.create(System.Double,System.Collections.Generic.IEnumerable{System.Double})">
<summary>
 Creates probability mass function    
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Empirical.exp(Microsoft.FSharp.Collections.FSharpMap{System.Double,System.Double})">
<summary>
 Exponentiates the probabilities
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Empirical.log(Microsoft.FSharp.Collections.FSharpMap{System.Double,System.Double})">
<summary>
 Log transforms the probabilities
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Empirical.var(Microsoft.FSharp.Collections.FSharpMap{System.Double,System.Double})">
<summary>
 Computes the variance of a PMF
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Empirical.varAround(System.Double,Microsoft.FSharp.Collections.FSharpMap{System.Double,System.Double})">
<summary>
 Computes the variance of a PMF around mu
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Empirical.mean(Microsoft.FSharp.Collections.FSharpMap{System.Double,System.Double})">
<summary>
 Computes the mean of a PMF
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Empirical.random(Microsoft.FSharp.Collections.FSharpMap{System.Double,System.Double})">
<summary>
 Chooses a random element from this PMF
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Empirical.normalizePDD(System.Double,Microsoft.FSharp.Collections.FSharpMap{System.Double,System.Double})">
<summary>
 Normalizes this PMF by the bandwidth to area equals 1.  (n/N)/Îx
 Probability Denisty Distribution
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Empirical.normalizeBandwidth(System.Double,Microsoft.FSharp.Collections.FSharpMap{System.Double,System.Double})">
<summary>
 Normalizes this PMF by the bandwidth n/Îx
 Frequency Denisty Distribution
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Empirical.normalizePercentage(Microsoft.FSharp.Collections.FSharpMap{System.Double,System.Double})">
<summary>
 Normalizes this PMF so the sum of all probabilities equals 100 percent 
 Discrete Percentage Probability Distribution
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Empirical.normalize(Microsoft.FSharp.Collections.FSharpMap{System.Double,System.Double})">
<summary>
 Normalizes this PMF so the sum of all probabilities equals 1. 
 Discrete Probability Distribution
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Empirical.normalizewith(System.Double,Microsoft.FSharp.Collections.FSharpMap{System.Double,System.Double})">
<summary>
 Normalizes this PMF so the sum of all probabilities equals fraction
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Empirical.probabilities(Microsoft.FSharp.Collections.FSharpMap{System.Double,System.Double})">
<summary>
 Gets an unsorted sequence of probabilities
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Empirical.probabilityAt(Microsoft.FSharp.Collections.FSharpMap{System.Double,System.Double},System.Double)">
<summary>
 Gets the probability associated with the value x
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Empirical.getYValues(Microsoft.FSharp.Collections.FSharpMap{System.Double,System.Double})">
<summary>
 Returns distinct values from pmf
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Empirical.getXValues(Microsoft.FSharp.Collections.FSharpMap{System.Double,System.Double})">
<summary>
 Returns distinct values from pmf
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Empirical.maxLike(Microsoft.FSharp.Collections.FSharpMap{System.Double,System.Double})">
<summary>
 Returns the largest probability in the map.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Empirical.sum(Microsoft.FSharp.Collections.FSharpMap{System.Double,System.Double})">
<summary>
 Returns the total of the probabilities in the map
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Empirical.getZip(Microsoft.FSharp.Collections.FSharpMap{System.Double,System.Double})">
<summary>
 Returns: tuple of (sorted value sequence, probability sequence)
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Empirical.ofHistogram``1(Microsoft.FSharp.Collections.FSharpMap{``0,System.Int32})">
<summary>
 Creates Pmf of a Histogram (normalize by n)
</summary>
</member>
<member name="T:FSharp.Stats.Distributions.Empirical">
<summary>
 Represents a probability mass function (map from values to probabilities).
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.ContinuousModule.LogNormal.Variance(System.Double,System.Double)">
<summary>
 Computes the variance.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.ContinuousModule.LogNormal.Support(System.Double,System.Double)">
<summary>
 Returns the support of the exponential distribution: [0, Positive Infinity).
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.ContinuousModule.LogNormal.StandardDeviation(System.Double,System.Double)">
<summary>
 Computes the standard deviation.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.ContinuousModule.LogNormal.Sample(System.Double,System.Double)">
<summary>
 Produces a random sample using the current random number generator (from GetSampleGenerator()).
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.ContinuousModule.LogNormal.PDF(System.Double,System.Double,System.Double)">
<summary>
 Computes the probability density function.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.ContinuousModule.LogNormal.Mean(System.Double,System.Double)">
<summary>
 Computes the mean.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.ContinuousModule.LogNormal.Estimate(System.Collections.Generic.IEnumerable{System.Double})">
<summary>
 Estimates the log-normal distribution parameters from sample data with maximum-likelihood.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.ContinuousModule.LogNormal.CDF``1(System.Double,System.Double,``0)">
<summary>
 Computes the cumulative distribution function.
</summary>
</member>
<member name="T:FSharp.Stats.Distributions.ContinuousModule.LogNormal">
<summary>
 Log-Normal distribution.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.ContinuousModule.F.Variance(System.Double,System.Double)">
<summary>
 Computes the variance.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.ContinuousModule.F.Support(System.Double,System.Double)">
<summary>
 Returns the support of the exponential distribution: (0., Positive Infinity).
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.ContinuousModule.F.StandardDeviation(System.Double,System.Double)">
<summary>
 Computes the standard deviation.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.ContinuousModule.F.Sample(System.Double,System.Double)">
<summary>
 Produces a random sample using the current random number generator (from GetSampleGenerator()).
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.ContinuousModule.F.PDF(System.Double,System.Double,System.Double)">
<summary>
 Computes the probability density function.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.ContinuousModule.F.Mean(System.Double,System.Double)">
<summary>
 Computes the mean.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.ContinuousModule.F.CDF(System.Double,System.Double,System.Double)">
<summary>
 Computes the cumulative distribution function.
</summary>
</member>
<member name="T:FSharp.Stats.Distributions.ContinuousModule.F">
<summary>
 F-distribution
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.ContinuousModule.StudentT.Variance(System.Double,System.Double,System.Double)">
<summary>
 Computes the variance.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.ContinuousModule.StudentT.Support(System.Double,System.Double,System.Double)">
<summary>
 Returns the support of the exponential distribution: (Negative Infinity, Positive Infinity).
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.ContinuousModule.StudentT.StandardDeviation(System.Double,System.Double,System.Double)">
<summary>
 Computes the standard deviation.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.ContinuousModule.StudentT.Sample(System.Double,System.Double,System.Double)">
<summary>
 Produces a random sample using the current random number generator (from GetSampleGenerator()).
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.ContinuousModule.StudentT.PDF(System.Double,System.Double,System.Double,System.Double)">
<summary>
 Computes the probability density function.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.ContinuousModule.StudentT.Mean(System.Double,System.Double,System.Double)">
<summary>
 Computes the mean.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.ContinuousModule.StudentT.CDF(System.Double,System.Double,System.Double,System.Double)">
<summary>
 Computes the cumulative distribution function.
</summary>
</member>
<member name="T:FSharp.Stats.Distributions.ContinuousModule.StudentT">
<summary>
 Student&apos;s T-distribution
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.ContinuousModule.Beta.Variance(System.Double,System.Double)">
<summary>
 Computes the variance.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.ContinuousModule.Beta.Support(System.Double,System.Double)">
<summary>
 Returns the support of the exponential distribution: [0.0, 1.0).
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.ContinuousModule.Beta.StandardDeviation(System.Double,System.Double)">
<summary>
 Computes the standard deviation.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.ContinuousModule.Beta.Sample(System.Double,System.Double)">
<summary>
 Produces a random sample using the current random number generator (from GetSampleGenerator()).
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.ContinuousModule.Beta.PDF(System.Double,System.Double,System.Double)">
<summary>
 Computes the probability density function.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.ContinuousModule.Beta.Mean(System.Double,System.Double)">
<summary>
 Computes the mean.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.ContinuousModule.Beta.CDF(System.Double,System.Double,System.Double)">
<summary>
 Computes the cumulative distribution function.
</summary>
</member>
<member name="T:FSharp.Stats.Distributions.ContinuousModule.Beta">
<summary>
 Beta distribution
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.ContinuousModule.Gamma.Variance(System.Double,System.Double)">
<summary>
 Computes the variance.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.ContinuousModule.Gamma.Support(System.Double,System.Double)">
<summary>
 Returns the support of the exponential distribution: [0, Positive Infinity).
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.ContinuousModule.Gamma.StandardDeviation(System.Double,System.Double)">
<summary>
 Computes the standard deviation.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.ContinuousModule.Gamma.Sample(System.Double,System.Double)">
<summary>
 Produces a random sample using the current random number generator (from GetSampleGenerator()).
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.ContinuousModule.Gamma.PDF(System.Double,System.Double,System.Double)">
<summary>
 Computes the probability density function.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.ContinuousModule.Gamma.Mean(System.Double,System.Double)">
<summary>
 Computes the mean.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.ContinuousModule.Gamma.CDF(System.Double,System.Double,System.Double)">
<summary>
 Computes the cumulative distribution function.
</summary>
</member>
<member name="T:FSharp.Stats.Distributions.ContinuousModule.Gamma">
<summary>
 Gamma distribution
 Sampling implementation based on:
     &quot;A Simple Method for Generating Gamma Variables&quot; - Marsaglia &amp; Tsang
     ACM Transactions on Mathematical Software, Vol. 26, No. 3, September 2000, Pages 363-372.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.ContinuousModule.Exponential.Variance(System.Double)">
<summary>
 Computes the variance.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.ContinuousModule.Exponential.Support(System.Double)">
<summary>
 Returns the support of the exponential distribution: [0, Positive Infinity).
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.ContinuousModule.Exponential.StandardDeviation(System.Double)">
<summary>
 Computes the standard deviation.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.ContinuousModule.Exponential.Sample(System.Double)">
<summary>
 Produces a random sample using the current random number generator (from GetSampleGenerator()).
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.ContinuousModule.Exponential.PDF(System.Double,System.Double)">
<summary>
 Computes the probability density function.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.ContinuousModule.Exponential.Mean(System.Double)">
<summary>
 Computes the mean.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.ContinuousModule.Exponential.CDF(System.Double,System.Double)">
<summary>
 Computes the cumulative distribution function.
</summary>
</member>
<member name="T:FSharp.Stats.Distributions.ContinuousModule.Exponential">
<summary>
 Exponential distribution.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.ContinuousModule.Normal.init(System.Double,System.Double)">
<summary>
 Initializes a Normal distribution        
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.ContinuousModule.Normal.Variance(System.Double,System.Double)">
<summary>
 Computes the variance.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.ContinuousModule.Normal.Support(System.Double,System.Double)">
<summary>
 Returns the support of the exponential distribution: [0, Positive Infinity).
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.ContinuousModule.Normal.StandardDeviation(System.Double,System.Double)">
<summary>
 Computes the standard deviation.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.ContinuousModule.Normal.Sample(System.Double,System.Double)">
<summary>
 Produces a random sample using the current random number generator (from GetSampleGenerator()).
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.ContinuousModule.Normal.PDF(System.Double,System.Double,System.Double)">
<summary>
 Computes the probability density function.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.ContinuousModule.Normal.Mean(System.Double,System.Double)">
<summary>
 Computes the mean.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.ContinuousModule.Normal.Estimate(System.Collections.Generic.IEnumerable{System.Double})">
<summary>
 Estimates the Normal distribution parameters from sample data with maximum-likelihood.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.ContinuousModule.Normal.CDF(System.Double,System.Double,System.Double)">
<summary>
 Computes the cumulative distribution function.
</summary>
</member>
<member name="T:FSharp.Stats.Distributions.ContinuousModule.Normal">
<summary>
 Normal distribution.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.ContinuousModule.Uniform.Variance(System.Double,System.Double)">
<summary>
 Computes the variance.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.ContinuousModule.Uniform.Support(System.Double,System.Double)">
<summary>
 Returns the support of the exponential distribution: [0, Positive Infinity).
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.ContinuousModule.Uniform.StandardDeviation(System.Double,System.Double)">
<summary>
 Computes the standard deviation.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.ContinuousModule.Uniform.Sample(System.Double,System.Double)">
<summary>
 Produces a random sample using the current random number generator (from GetSampleGenerator()).
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.ContinuousModule.Uniform.PDF(System.Double,System.Double,System.Double)">
<summary>
 Computes the probability density function.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.ContinuousModule.Uniform.Mean(System.Double,System.Double)">
<summary>
 Computes the mean.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.ContinuousModule.Uniform.CDF(System.Double,System.Double,System.Double)">
<summary>
 Computes the cumulative distribution function.
</summary>
</member>
<member name="T:FSharp.Stats.Distributions.ContinuousModule.Uniform">
<summary>
 Uniform distribution.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.ContinuousModule.ChiSquared.Variance(System.Double)">
<summary>
 Computes the variance.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.ContinuousModule.ChiSquared.Support(System.Double)">
<summary>
 Returns the support of the exponential distribution: [0, Positive Infinity).
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.ContinuousModule.ChiSquared.StandardDeviation(System.Double)">
<summary>
 Computes the standard deviation.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.ContinuousModule.ChiSquared.Sample(System.Double)">
<summary>
 Produces a random sample using the current random number generator (from GetSampleGenerator()).
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.ContinuousModule.ChiSquared.PDFLn(System.Double,System.Double)">
<summary>
 Computes the logarithm of probability density function.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.ContinuousModule.ChiSquared.PDF(System.Double,System.Double)">
<summary>
 Computes the probability density function.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.ContinuousModule.ChiSquared.Mean(System.Double)">
<summary>
 Computes the mean.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.ContinuousModule.ChiSquared.CDF(System.Double,System.Double)">
<summary>
 Computes the cumulative distribution function.
</summary>
</member>
<member name="T:FSharp.Stats.Distributions.ContinuousModule.ChiSquared">
<summary>
 ChiSquared distribution.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.ContinuousModule.logNormal(System.Double,System.Double)">
<summary>
 Initializes a Normal distribution        
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.ContinuousModule.f(System.Double,System.Double)">
<summary>
 Initializes a F-distribution         
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.ContinuousModule.studentT(System.Double,System.Double,System.Double)">
<summary>
 Initializes a Student&apos;s T-distribution        
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.ContinuousModule.beta(System.Double,System.Double)">
<summary>
 Initializes a Beta distribution        
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.ContinuousModule.gamma(System.Double,System.Double)">
<summary>
 Initializes a Gamma distribution        
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.ContinuousModule.exponential(System.Double)">
<summary>
 Initializes a Exponential distribution        
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.ContinuousModule.normal(System.Double,System.Double)">
<summary>
 Initializes a Normal distribution        
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.ContinuousModule.uniform(System.Double,System.Double)">
<summary>
 Initializes a uniform distribution        
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.ContinuousModule.chiSquared(System.Double)">
<summary>
 Initializes a ChiSquared distribution        
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Discrete.Wilcoxon.Variance(System.Double,System.Int32)">
<summary>
 Computes the variance.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Discrete.Wilcoxon.Support(System.Double,System.Int32)">
<summary>
 Returns the support of the Binomial distribution: (0., n).
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Discrete.Wilcoxon.StandardDeviation(System.Double,System.Int32)">
<summary>
 Computes the standard deviation.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Discrete.Wilcoxon.SampleUnchecked(System.Double,System.Int32)">
<summary>
 Produces a random sample using the current random number generator (from GetSampleGenerator()).
 No parameter checking!
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Discrete.Wilcoxon.Sample(System.Double,System.Int32)">
<summary>
 Produces a random sample using the current random number generator (from GetSampleGenerator()).
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Discrete.Wilcoxon.PDF(System.Double,System.Int32,System.Int32)">
<summary>
 Computes the probability density function at k, i.e. P(K = k)
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Discrete.Wilcoxon.Mean(System.Double,System.Int32)">
<summary>
 Computes the mean.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Discrete.Wilcoxon.CDF(System.Double,System.Int32,System.Double)">
<summary>
 Computes the cumulative distribution function at x, i.e. P(X &lt;= x).
</summary>
</member>
<member name="T:FSharp.Stats.Distributions.Discrete.Wilcoxon">
<summary>
Wilcoxon distribution
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Discrete.Binomial.Variance(System.Double,System.Int32)">
<summary>
 Computes the variance.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Discrete.Binomial.Support(System.Double,System.Int32)">
<summary>
 Returns the support of the Binomial distribution: (0., n).
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Discrete.Binomial.StandardDeviation(System.Double,System.Int32)">
<summary>
 Computes the standard deviation.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Discrete.Binomial.SampleUnchecked(System.Double,System.Int32)">
<summary>
 Produces a random sample using the current random number generator (from GetSampleGenerator()).
 No parameter checking!
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Discrete.Binomial.Sample(System.Double,System.Int32)">
<summary>
 Produces a random sample using the current random number generator (from GetSampleGenerator()).
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Discrete.Binomial.PDF(System.Double,System.Int32,System.Int32)">
<summary>
 Computes the probability density function at k, i.e. P(K = k)
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Discrete.Binomial.Mean(System.Double,System.Int32)">
<summary>
 Computes the mean.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Discrete.Binomial.CDF(System.Double,System.Int32,System.Double)">
<summary>
 Computes the cumulative distribution function at x, i.e. P(X &lt;= x).
</summary>
</member>
<member name="T:FSharp.Stats.Distributions.Discrete.Binomial">
<summary>
Binomial distribution
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Discrete.Hypergeometric.Variance(System.Int32,System.Int32,System.Int32)">
<summary>
 Computes the variance.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Discrete.Hypergeometric.Support(System.Int32,System.Int32,System.Int32)">
<summary>
 Returns the support of the hypergeometric distribution: (0., Positive Infinity).
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Discrete.Hypergeometric.StandardDeviation(System.Int32,System.Int32,System.Int32)">
<summary>
 Computes the standard deviation.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Discrete.Hypergeometric.SampleUnchecked(System.Int32,System.Int32,System.Int32)">
<summary>
 Produces a random sample using the current random number generator (from GetSampleGenerator()).
 No parameter checking!
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Discrete.Hypergeometric.Sample(System.Int32,System.Int32,System.Int32)">
<summary>
 Produces a random sample using the current random number generator (from GetSampleGenerator()).
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Discrete.Hypergeometric.PDF(System.Int32,System.Int32,System.Int32,System.Int32)">
<summary>
 Computes the probability density function at k, i.e. P(K = k)
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Discrete.Hypergeometric.Mean(System.Int32,System.Int32,System.Int32)">
<summary>
 Computes the mean.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Discrete.Hypergeometric.CDF(System.Int32,System.Int32,System.Int32,System.Double)">
<summary>
 Computes the cumulative distribution function at x, i.e. P(X &lt;= x).
</summary>
</member>
<member name="T:FSharp.Stats.Distributions.Discrete.Hypergeometric">
<summary>
Hypergeometric distribution
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Discrete.Bernoulli.Variance(System.Double)">
<summary>
 Computes the variance.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Discrete.Bernoulli.Support(System.Double)">
<summary>
 Returns the support of the exponential distribution: [0, Positive Infinity).
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Discrete.Bernoulli.StandardDeviation(System.Double)">
<summary>
 Computes the standard deviation.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Discrete.Bernoulli.Sample``1(System.Double)">
<summary>
 Produces a random sample using the current random number generator (from GetSampleGenerator()).
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Discrete.Bernoulli.PDF(System.Double,System.Double)">
<summary>
 Computes the probability density function.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Discrete.Bernoulli.Mean(System.Double)">
<summary>
 Computes the mean.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Discrete.Bernoulli.CDF(System.Double,System.Double)">
<summary>
 Computes the cumulative distribution function.
</summary>
</member>
<member name="T:FSharp.Stats.Distributions.Discrete.Bernoulli">
<summary>
 Bernoulli distribution.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Discrete.wilcoxon(System.Double,System.Int32)">
<summary>
 Initializes a Wilcoxon distribution       
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Discrete.binomial(System.Double,System.Int32)">
<summary>
 Initializes a Binomial distribution       
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Discrete.hypergeometric(System.Int32,System.Int32,System.Int32)">
<summary>
 Initializes a hypergeometric distribution       
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Discrete.bernoulli(System.Double)">
<summary>
 Initializes a uniform distribution        
</summary>
</member>
<member name="T:FSharp.Stats.Distributions.Discrete">
<summary>
 Discrete probability distributions
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.KernelDensity.mapInPlace``1(Microsoft.FSharp.Core.FSharpFunc{``0,``0},``0[])">
<summary>
 Applying the given function to each of the elements of the array and returns the value in place.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.KernelDensity.Kernel.cosine(System.Double,System.Double)">
<summary>
 Cosine kernel
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.KernelDensity.Kernel.biweight(System.Double,System.Double)">
<summary>
 Biweight kernel
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.KernelDensity.Kernel.epanechnikov(System.Double,System.Double)">
<summary>
 Epanechnikov kernel
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.KernelDensity.Kernel.triangular(System.Double,System.Double)">
<summary>
 Triangular kernel
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.KernelDensity.Kernel.rectangular(System.Double,System.Double)">
<summary>
 Rectangular kernel
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.KernelDensity.Kernel.gaussian(System.Double,System.Double)">
<summary>
 Gausian kernel
</summary>
</member>
<member name="T:FSharp.Stats.Distributions.KernelDensity">
<summary>
 Module to perform Kernel density estimation
</summary>
</member>
<member name="T:FSharp.Stats.Testing.TestStatistics.ChiSquareStatistics">
 <summary>
   Computes the Chi-Square test statistics for a given statistic
   with given degrees of freedom.
 </summary>
 
 <param name="Statistic">The test statistic.</param>
 <param name="DegreesOfFreedom">The degrees of freedom for the numerator.</param>    
 <param name="PValueLeft">One Tailed/Sided.</param>
 <param name="PValueRight"> One Tailed/Sided.</param>   
 <param name="PValue">Two Tailed/Sided.</param>   
</member>
<member name="T:FSharp.Stats.Testing.TestStatistics.FTestStatistics">
 <summary>
   Creates a new F-Test for a given statistic
   with given degrees of freedom.
 </summary>
 
 <param name="statistic">The test statistic.</param>
 <param name="d1">The degrees of freedom for the numerator.</param>
 <param name="d2">The degrees of freedom for the denominator.</param>
</member>
<member name="T:FSharp.Stats.Testing.TestStatistics.TTestStatistics">
 <summary>
   Creates a new T-Test for a given statistic
   with given degrees of freedom.
 </summary>
 
 <param name="Statistic">The test statistic.</param>
 <param name="DegreesOfFreedom">The degrees of freedom for the numerator.</param>    
 <param name="PValueLeft">One Tailed/Sided.</param>
 <param name="PValueRight"> One Tailed/Sided.</param>   
 <param name="PValue">Two Tailed/Sided.</param>   
</member>
<member name="M:FSharp.Stats.Testing.Anova.twoWayANOVA(FSharp.Stats.Testing.Anova.TwoWayAnovaModel,System.Double[][][])">
<summary>
 Calculates two-way ANOVA as an extension of the one-way ANOVA for two independent variables.
</summary>
</member>
<member name="M:FSharp.Stats.Testing.Anova.oneWayAnova``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
 Calculates one-way analysis of variance (one-way ANOVA) which is a technique used to compare means of two or more samples (using the F distribution)
 The ANOVA tests the null hypothesis that samples in two or more groups are drawn from populations with the same mean values.
</summary>
</member>
<member name="M:FSharp.Stats.Testing.TTest.twoSamplePaired(FSharp.Stats.Vector{System.Double},FSharp.Stats.Vector{System.Double})">
<summary>
 which observations in one sample can be paired with observations in the other sample.
</summary>
</member>
<member name="M:FSharp.Stats.Testing.TTest.twoSample(System.Boolean,FSharp.Stats.Vector{System.Double},FSharp.Stats.Vector{System.Double})">
<summary>
 Computes a t-test or a Welch test 
</summary>
</member>
<member name="M:FSharp.Stats.Testing.TTest.noAssumtion(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
<summary>
 Equal or unequal sample sizes, assume nothing about variance.
 input: (mean1,variance1,N1) (mean2,variance2,N3)
</summary>
</member>
<member name="M:FSharp.Stats.Testing.ChiSquareTest.compute(System.Int32,System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Double})">
<summary>
 Computes the Chi-Square test
</summary>
</member>
<member name="T:FSharp.Stats.Testing.ChiSquareTest">
 <summary>
   Two-Sample (Goodness-of-fit) Chi-Square Test (Upper Tail)
 </summary>
 
 <remarks>
 <para>
   A chi-square test (also chi-squared or Ï2  test) is any statistical
   hypothesis test in which the sampling distribution of the test statistic
   is a <see cref="ChiSquareDistribution">chi-square distribution</see> when
   the null hypothesis is true, or any in which this is asymptotically true,
   meaning that the sampling distribution (if the null hypothesis is true) 
   can be made to approximate a chi-square distribution as closely as desired
   by making the sample size large enough.</para>
 <para>
   The chi-square test is used whenever one would like to test whether the
   actual data differs from a random distribution. </para>
   
 <para>
   References:
   <list type="bullet">
     <item><description><a href="http://en.wikipedia.org/wiki/Chi-square_test">
        Wikipedia, The Free Encyclopedia. Chi-Square Test. Available on:
        http://en.wikipedia.org/wiki/Chi-square_test </a></description></item>
   
     <item><description><a href="http://www2.lv.psu.edu/jxm57/irp/chisquar.html">
        J. S. McLaughlin. Chi-Square Test. Available on:
        http://www2.lv.psu.edu/jxm57/irp/chisquar.html </a></description></item>
   </list></para>
 </remarks>
 
</member>
<member name="M:FSharp.Stats.Testing.Bartlett.compute``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
 Bartlett&apos;s test for equality of variances
 Tests the null hypothesis that all group variances are equal
</summary>
</member>
<member name="M:FSharp.Stats.Testing.PostHoc.TukeyHSD(System.Double[][],System.Double[][])">
<summary>
 Tukey-Kramer approach
</summary>
</member>
<member name="M:FSharp.Stats.Testing.PvalueAdjust.Benjamini_Hochberg``1(System.Collections.Generic.IEnumerable{System.Tuple{``0,System.Double}})">
<summary>
 Benjamini-Hochberg Correction (BH)
</summary>
</member>
<member name="M:FSharp.Stats.Testing.PvalueAdjust.Qvalues.ofPValues(System.Double,System.Double[])">
<summary>
 Calculates q-values from given p-values.
</summary>
</member>
<member name="M:FSharp.Stats.Testing.PvalueAdjust.Qvalues.ofPValuesRobust(System.Double,System.Double[])">
<summary>
 Calculates the robust version of the q-value. See Storey JD (2002) JRSS-B 64: 479-498.
</summary>
</member>
<member name="M:FSharp.Stats.Testing.PvalueAdjust.Qvalues.pi0_Bootstrap(System.Double[])">
<summary>
 Estimates pi0 from given p-Values by Storeys bootstrap method using default lambda&apos;s
</summary>
</member>
<member name="M:FSharp.Stats.Testing.PvalueAdjust.Qvalues.pi0_BootstrapWithLambda(System.Double[],System.Double[])">
<summary>
 Estimates pi0 from given p-Values by Storeys bootstrap method
</summary>
</member>
<member name="P:FSharp.Stats.Testing.SAM.SAM.Statistics">
<summary>
 test statistics
</summary>
</member>
<member name="P:FSharp.Stats.Testing.SAM.SAM.Si">
<summary>
 pooled standard error 
</summary>
</member>
<member name="P:FSharp.Stats.Testing.SAM.SAM.Ri">
<summary>
 relative diffence of mean
</summary>
</member>
<member name="T:FSharp.Stats.Testing.SAM.SAM">
<summary>
 Represents the relative difference, the pooled standard error and the test statistics
</summary>
</member>
<member name="M:FSharp.Stats.Testing.SAM.getSymmetricCuts(FSharp.Stats.Testing.SAM.SAM[],FSharp.Stats.Testing.SAM.SAM[])">
<summary>
Finds all pairs of symmetric cutoffs
</summary>
</member>
<member name="M:FSharp.Stats.Testing.SAM.getAsymmetricCuts(FSharp.Stats.Testing.SAM.SAM[],FSharp.Stats.Testing.SAM.SAM[])">
<summary>
Finds all pairs of asymmetric cutoffs according to the differences between di and dEi
</summary>
</member>
<member name="M:FSharp.Stats.Testing.SAM.estimatePi0(FSharp.Stats.Testing.SAM.SAM[],FSharp.Stats.Testing.SAM.SAM[][])">
<summary>
 Estimates pi0. Chosen to minimize the coefficient of variation of the test statistics 
</summary>
</member>
<member name="M:FSharp.Stats.Testing.SAM.countIf``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},``0[])">
<summary>
 Iterates over elements of the input array and increase the counter if the function returens true
</summary>
</member>
<member name="M:FSharp.Stats.Testing.SAM.permutationImbalanced``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{System.Double[][],Microsoft.FSharp.Core.FSharpFunc{System.Double[][],FSharp.Stats.Testing.SAM.SAM[]}}},System.Int32,``0,System.Double[][],System.Double[][])">
<summary>
 Permutes all the samples. Different treatments are mixed.
</summary>
</member>
<member name="M:FSharp.Stats.Testing.SAM.permutationBalanced``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{System.Double[][],Microsoft.FSharp.Core.FSharpFunc{System.Double[][],FSharp.Stats.Testing.SAM.SAM[]}}},System.Int32,``0,System.Double[][],System.Double[][])">
<summary>
 Permutes all the samples. Different treatments are mixed.
</summary>
</member>
<member name="M:FSharp.Stats.Testing.SAM.permutationWithin``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{System.Double[][],Microsoft.FSharp.Core.FSharpFunc{System.Double[][],FSharp.Stats.Testing.SAM.SAM[]}}},System.Int32,``0,System.Double[][],System.Double[][])">
<summary>
Permutes all the samples. Different treatments are NOT mixed. Then the statistics for the permuatations is calculated.
</summary>
</member>
<member name="M:FSharp.Stats.Testing.SAM.calculateTwoClassUnpaired(System.Double,System.Double[][],System.Double[][])">
<summary>
 Calculates SAM test statistics for two class unpaired data
</summary>
</member>
<member name="M:FSharp.Stats.Testing.SAM.createSAM(System.Double,System.Double,System.Double)">
<summary>
 Creates the type SAM
</summary>
</member>
<member name="M:FSharp.Stats.Testing.SAM.S0.estimateFrom(Microsoft.FSharp.Core.FSharpFunc{System.Double,Microsoft.FSharp.Core.FSharpFunc{System.Double[][],Microsoft.FSharp.Core.FSharpFunc{System.Double[][],FSharp.Stats.Testing.SAM.SAM[]}}},System.Double[][],System.Double[][])">
<summary>
 Estimates s0 from given data set. Chosen to minimize the coefficient of variation of the test statistics 
</summary>
</member>
<member name="M:FSharp.Stats.Testing.SAM.S0.estimate(FSharp.Stats.Testing.SAM.SAM[])">
<summary>
 Estimates s0. Chosen to minimize the coefficient of variation of the test statistics 
</summary>
</member>
<member name="M:FSharp.Stats.Testing.SAM.S0.median(FSharp.Stats.Testing.SAM.SAM[])">
<summary>
 Creates s0 by calulating the mean of si (pooled standard error )
</summary>
</member>
<member name="M:FSharp.Stats.Testing.SAM.S0.nearestRank(System.Double,FSharp.Stats.Testing.SAM.SAM[])">
<summary>
 Computes s0 using the nearest rank method
</summary>
</member>
<member name="T:FSharp.Stats.Testing.SAM.S0">
<summary>
 Module with different estimation methods computing s0 
</summary>
</member>
<member name="M:FSharp.Stats.Testing.FisherHotelling.test(System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Double})">
<summary>
 Pearson correlation (nan support by JackKnife leave one out)
</summary>
</member>
<member name="M:FSharp.Stats.Testing.FisherHotelling.stdFisherHotellingZ(System.Int32)">
<summary>
 Standart deviation Fisher-Z transformation for Pearson correlation coefficient
 after Hotelling (1953) for n&lt; 50
</summary>
</member>
<member name="M:FSharp.Stats.Testing.FisherHotelling.transformFisherHotellingZ(System.Double,System.Double)">
<summary>
 Fisher-Z transformation for Pearson correlation coefficient    
 after Hotelling (1953) for n &lt; 50
</summary>
</member>
<member name="M:FSharp.Stats.Testing.FisherHotelling.stdFisherZ(System.Int32)">
<summary>
 Standart deviation Fisher-Z transformation for Pearson correlation coefficient
</summary>
</member>
<member name="M:FSharp.Stats.Testing.FisherHotelling.transformFisherZ(System.Double)">
<summary>
 Fisher-Z transformation for Pearson correlation coefficient    
</summary>
</member>
<member name="T:FSharp.Stats.Testing.FisherHotelling">
<summary>
 Fisher-Z transformation for Pearson correlation coefficient after Hotelling (1953) for n&lt; 50
</summary>
</member>
<member name="T:FSharp.Stats.Fitting.NonLinearRegression.SolverOptions">

</member>
<member name="P:FSharp.Stats.Fitting.NonLinearRegression.Model.GetGradientValue">
<summary>
Gradient: Vector of partial derivations of function body
</summary>
</member>
<member name="P:FSharp.Stats.Fitting.NonLinearRegression.Model.GetFunctionValue">
<summary>
originally GetValue; contains function body
</summary>
</member>
<member name="T:FSharp.Stats.Fitting.NonLinearRegression.Model">

</member>
<member name="M:FSharp.Stats.Fitting.NonLinearRegression.solverConverged(FSharp.Stats.Fitting.NonLinearRegression.SolverOptions,System.Collections.Generic.List{FSharp.Stats.Vector{System.Double}})">

</member>
<member name="M:FSharp.Stats.Fitting.NonLinearRegression.shouldTerminate(System.Double,System.Double,System.Int32,FSharp.Stats.Vector{System.Double},FSharp.Stats.Vector{System.Double},FSharp.Stats.Fitting.NonLinearRegression.SolverOptions)">
<summary>
 Returns true if convergence criteria are met or a user defined number of iiterations has been carried out
</summary>
</member>
<member name="M:FSharp.Stats.Fitting.NonLinearRegression.updateResidualVectorInPlace(FSharp.Stats.Fitting.NonLinearRegression.Model,System.Double[],System.Double[],FSharp.Stats.Vector{System.Double},FSharp.Stats.Vector{System.Double})">
<summary>
 Returns the residual vector, each row i contains the difference between the yEst_i and the yData_i. 
</summary>
</member>
<member name="M:FSharp.Stats.Fitting.NonLinearRegression.getRSS(FSharp.Stats.Fitting.NonLinearRegression.Model,System.Double[],System.Double[],FSharp.Stats.Vector{System.Double})">
<summary>
 Returns the residual sum of squares (RSS) as a measure of discrepancy between the data and the used estimation model.
</summary>
</member>
<member name="M:FSharp.Stats.Fitting.NonLinearRegression.createSolverOption(System.Double,System.Double,System.Int32,System.Double[])">

</member>
<member name="M:FSharp.Stats.Fitting.NonLinearRegression.createModel(System.String[],Microsoft.FSharp.Core.FSharpFunc{FSharp.Stats.Vector{System.Double},Microsoft.FSharp.Core.FSharpFunc{System.Double,System.Double}},Microsoft.FSharp.Core.FSharpFunc{FSharp.Stats.Vector{System.Double},Microsoft.FSharp.Core.FSharpFunc{FSharp.Stats.Vector{System.Double},Microsoft.FSharp.Core.FSharpFunc{System.Double,FSharp.Stats.Vector{System.Double}}}})">

</member>
<member name="M:FSharp.Stats.Fitting.NonLinearRegression.standardErrorOfPrediction(System.Double,System.Double[],System.Double[])">

</member>
<member name="P:FSharp.Stats.Fitting.NonLinearRegression.Table.emgModel">
<summary>
 Exponentially modified Gaussian (EMG) of the form &quot;y =  ((amp*std)/tau) * sqrt(PI/2.) * exp(1./2. * ((std/tau)**2.) - ((x-meanX)/tau)) * Erfc((1./sqrt(2.)) * ((std/tau)-((x-meanX)/std)))&quot;
</summary>
</member>
<member name="P:FSharp.Stats.Fitting.NonLinearRegression.Table.gaussModel">
<summary>
 Gaussian function of the form &quot;y = amp * exp( -1. * ( ( ( (x-meanX)**2. ) / (2.*std**2.)) ) )&quot;
</summary>
</member>
<member name="P:FSharp.Stats.Fitting.NonLinearRegression.Table.parabolaModel">
<summary>
 paraboola model of the form &quot;y = a * x^2 + b * x + c&quot;
</summary>
</member>
<member name="P:FSharp.Stats.Fitting.NonLinearRegression.Table.lineModel">
<summary>
 Line  
 Line model of the form &quot;y = a * x + b&quot;
</summary>
</member>
<member name="M:FSharp.Stats.Fitting.NonLinearRegression.LevenbergMarquardt.estimatedParams(FSharp.Stats.Fitting.NonLinearRegression.Model,FSharp.Stats.Fitting.NonLinearRegression.SolverOptions,System.Double,System.Double,System.Double[],System.Double[])">
<summary>
 Returns a parameter vector as a possible solution for linear least square based nonlinear fitting of a given dataset (xData, yData) with a given 
 model function. 
</summary>
</member>
<member name="M:FSharp.Stats.Fitting.NonLinearRegression.LevenbergMarquardt.estimatedParamsVerbose(FSharp.Stats.Fitting.NonLinearRegression.Model,FSharp.Stats.Fitting.NonLinearRegression.SolverOptions,System.Double,System.Double,System.Double[],System.Double[])">
<summary>
 Returns an collection of parameter vectors as a possible solution for linear least square based nonlinear fitting of a given dataset (xData, yData) with a given 
 model function. 
</summary>
</member>
<member name="M:FSharp.Stats.Fitting.NonLinearRegression.GaussNewton.estimatedParams(FSharp.Stats.Fitting.NonLinearRegression.Model,FSharp.Stats.Fitting.NonLinearRegression.SolverOptions,System.Double[],System.Double[])">
<summary>
 Returns a parameter vector as a possible solution for linear least square based nonlinear fitting of a given dataset (xData, yData) with a given 
 model function. 
</summary>
</member>
<member name="M:FSharp.Stats.Fitting.NonLinearRegression.GaussNewton.estimatedParamsVerbose(FSharp.Stats.Fitting.NonLinearRegression.Model,FSharp.Stats.Fitting.NonLinearRegression.SolverOptions,System.Double[],System.Double[])">
<summary>
 Returns an collection of parameter vectors as a possible solution for linear least square based nonlinear fitting of a given dataset (xData, yData) with a given 
 model function. 
</summary>
</member>
<member name="P:FSharp.Stats.Fitting.LinearRegression.SumOfSquares.Count">
<summary>
 Count N
</summary>
</member>
<member name="P:FSharp.Stats.Fitting.LinearRegression.SumOfSquares.Total">
<summary>
 Total sum of squares (SST - total)
</summary>
</member>
<member name="P:FSharp.Stats.Fitting.LinearRegression.SumOfSquares.Error">
<summary>
 Error sum of squares (SSE - unexplained)
</summary>
</member>
<member name="P:FSharp.Stats.Fitting.LinearRegression.SumOfSquares.Regression">
<summary>
 Regression sum of squares (SSR - explained) 
</summary>
</member>
<member name="T:FSharp.Stats.Fitting.LinearRegression.SumOfSquares">
<summary>
 Three sum of squares 
</summary>
</member>
<member name="M:FSharp.Stats.Fitting.LinearRegression.calculateANOVA(System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Double,System.Double},FSharp.Stats.Vector{System.Double},FSharp.Stats.Vector{System.Double})">
<summary>
 explained = total - unexplained
</summary>
</member>
<member name="M:FSharp.Stats.Fitting.LinearRegression.calculateSST(Microsoft.FSharp.Core.FSharpFunc{System.Double,System.Double},FSharp.Stats.Vector{System.Double},FSharp.Stats.Vector{System.Double})">
<summary>
 Calculates SST: sum of squares total
 also: total sum of squares
</summary>
</member>
<member name="M:FSharp.Stats.Fitting.LinearRegression.calculateSSE(Microsoft.FSharp.Core.FSharpFunc{System.Double,System.Double},FSharp.Stats.Vector{System.Double},FSharp.Stats.Vector{System.Double})">
<summary>
 Calculates SSE: sum of squares of errors
 also: unexplained sum of squares    
</summary>
</member>
<member name="M:FSharp.Stats.Fitting.LinearRegression.getResiduals(Microsoft.FSharp.Core.FSharpFunc{System.Double,System.Double},FSharp.Stats.Vector{System.Double},FSharp.Stats.Vector{System.Double})">
<summary>
 Calculates the residuals
</summary>
</member>
<member name="M:FSharp.Stats.Fitting.LinearRegression.calcBIC(System.Double,System.Double,System.Double)">
<summary>
 Calculates Bayesian information criterion (BIC) which is a measure of the relative quality of a regression model for a given set of data
</summary>
</member>
<member name="M:FSharp.Stats.Fitting.LinearRegression.calcAIC(System.Double,System.Double,System.Double)">
<summary>
 Calculates Akaike information criterion (AIC) which is a measure of the relative quality of a regression model for a given set of data    
</summary>
</member>
<member name="M:FSharp.Stats.Fitting.LinearRegression.calulcateDeterminationFromValue(System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Double})">
<summary>
 Gets the coefficient of determination, as known as the R-Squared (RÂ²)
</summary>
</member>
<member name="M:FSharp.Stats.Fitting.LinearRegression.stDevIntercept(FSharp.Stats.Fitting.LinearRegression.SumOfSquares)">
<summary>
 Standard deviation of intercept (alpha)
</summary>
</member>
<member name="M:FSharp.Stats.Fitting.LinearRegression.stDevSlope(FSharp.Stats.Fitting.LinearRegression.SumOfSquares)">
<summary>
 Standard deviation of slope (beta)    
</summary>
</member>
<member name="M:FSharp.Stats.Fitting.LinearRegression.stDevY(FSharp.Stats.Fitting.LinearRegression.SumOfSquares)">
<summary>
 Standard deviation of y(x) 
</summary>
</member>
<member name="M:FSharp.Stats.Fitting.LinearRegression.calulcateSumOfSquares(Microsoft.FSharp.Core.FSharpFunc{System.Double,System.Double},System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Double})">

</member>
<member name="M:FSharp.Stats.Fitting.LinearRegression.OrdinaryLeastSquares.Polynomial.cooksDistance(System.Int32,FSharp.Stats.Vector{System.Double},FSharp.Stats.Vector{System.Double})">
<summary>
 Fits a polynomial model of user defined order to the data and returns the cooks distance for every data pair present in the
 input collections as an estimator for the influence of each data point in coefficient estimation.  
</summary>
</member>
<member name="M:FSharp.Stats.Fitting.LinearRegression.OrdinaryLeastSquares.Polynomial.fit(System.Int32,FSharp.Stats.Vector{System.Double},System.Double)">
<summary>
 Fit to x
</summary>
</member>
<member name="M:FSharp.Stats.Fitting.LinearRegression.OrdinaryLeastSquares.Polynomial.coefficient(System.Int32,FSharp.Stats.Vector{System.Double},FSharp.Stats.Vector{System.Double})">
<summary>
 Caclualtes the coefficients for polynomial regression
</summary>
</member>
<member name="T:FSharp.Stats.Fitting.LinearRegression.OrdinaryLeastSquares.Polynomial">
<summary>
 Simple polynomial regression
</summary>
</member>
<member name="M:FSharp.Stats.Fitting.LinearRegression.OrdinaryLeastSquares.Linear.Multivariable.fit(FSharp.Stats.Vector{System.Double},FSharp.Stats.Vector{System.Double})">
<summary>
 Fit to x
</summary>
</member>
<member name="M:FSharp.Stats.Fitting.LinearRegression.OrdinaryLeastSquares.Linear.Multivariable.coefficients(FSharp.Stats.Matrix{System.Double},FSharp.Stats.Vector{System.Double})">
<summary>
 Caclualtes the coefficients for linear regression
 in the form of [|intercept; slope;|]
</summary>
</member>
<member name="M:FSharp.Stats.Fitting.LinearRegression.OrdinaryLeastSquares.Linear.Univariable.cooksDistance(FSharp.Stats.Vector{System.Double},FSharp.Stats.Vector{System.Double})">
<summary>
 Fits a model (y(x) = b + m * x) to the data and returns the cooks distance for every data pair present in the
 input collections as an estimator for the influence of each data point in coefficient estimation.  
</summary>
</member>
<member name="M:FSharp.Stats.Fitting.LinearRegression.OrdinaryLeastSquares.Linear.Univariable.fit(FSharp.Stats.Vector{System.Double},System.Double)">
<summary>
 Fit to x
</summary>
</member>
<member name="M:FSharp.Stats.Fitting.LinearRegression.OrdinaryLeastSquares.Linear.Univariable.coefficient(FSharp.Stats.Vector{System.Double},FSharp.Stats.Vector{System.Double})">
<summary>
 Caclualtes the coefficients for linear regression
 in the form of [|intercept; slope;|]
</summary>
</member>
<member name="M:FSharp.Stats.Fitting.LinearRegression.OrdinaryLeastSquares.Linear.RTO.calculateANOVA(System.Double,FSharp.Stats.Vector{System.Double},FSharp.Stats.Vector{System.Double})">

</member>
<member name="M:FSharp.Stats.Fitting.LinearRegression.OrdinaryLeastSquares.Linear.RTO.fit(System.Double,System.Double)">
<summary>
 Fit to x
 coefficient is beta only
</summary>
</member>
<member name="M:FSharp.Stats.Fitting.LinearRegression.OrdinaryLeastSquares.Linear.RTO.fitFunc(System.Double,System.Double)">
<summary>
 Returns the regression function
 coefficient is beta only
</summary>
</member>
<member name="M:FSharp.Stats.Fitting.LinearRegression.OrdinaryLeastSquares.Linear.RTO.coefficient(Microsoft.FSharp.Collections.FSharpList{System.Double},Microsoft.FSharp.Collections.FSharpList{System.Double})">
<summary>
 Caclualtes the coefficients for linear regression through the origin 
</summary>
</member>
<member name="M:FSharp.Stats.Fitting.LinearRegression.OrdinaryLeastSquares.Linear.RTO.coefficientOfVector(FSharp.Stats.Vector{System.Double},FSharp.Stats.Vector{System.Double})">
<summary>
 Caclualtes the coefficients for linear regression through the origin 
</summary>
</member>
<member name="T:FSharp.Stats.Fitting.LinearRegression.OrdinaryLeastSquares.Linear.RTO">
<summary>
 Regression through the origin (y : x -&gt; bx)
</summary>
</member>
<member name="T:FSharp.Stats.Fitting.LinearRegression.OrdinaryLeastSquares.Linear">
<summary>
 Simple linear regression y : x -&gt; a + bx
</summary>
</member>
<member name="M:FSharp.Stats.Fitting.QuantileNormalization.quantileNorm(System.Collections.Generic.IEnumerable{System.Double[]})">
<summary>
 Computes the quantile normalization of a given dataset  
</summary>
</member>
<member name="M:FSharp.Stats.Fitting.Spline.smoothingSpline(System.Tuple{System.Double,System.Double}[],System.Double[])">
<summary>
 Creates a smoothing spline through some data. Takes as spline points the x-values given by basispts
</summary>
</member>
<member name="M:FSharp.Stats.Fitting.Spline.preprocess(System.Tuple{System.Double,System.Double}[])">
<summary>
 Some preprocessing of the input data
</summary>
</member>
<member name="P:FSharp.Stats.ML.SurprisalAnalysis.SAResult.Potentials">

</member>
<member name="P:FSharp.Stats.ML.SurprisalAnalysis.SAResult.MolecularPhenotypes">

</member>
<member name="P:FSharp.Stats.ML.SurprisalAnalysis.SAResult.SingularValues">
<summary>
Vector containing the singular values resulting from the thin SVD of the input matrix in descending order
</summary>
</member>
<member name="P:FSharp.Stats.ML.SurprisalAnalysis.SAResult.SingularValuesDiag">
<summary>
diagonal matrix containing the singular values resulting from the thin SVD of the input matrix
</summary>
</member>
<member name="P:FSharp.Stats.ML.SurprisalAnalysis.SAResult.RightSingularVectors">
<summary>
right singular vectors resulting from the thin SVD of the input matrix
</summary>
</member>
<member name="P:FSharp.Stats.ML.SurprisalAnalysis.SAResult.LeftSingularVecors">
<summary>
left singular vectors resulting from the thin SVD of the input matrix
</summary>
</member>
<member name="T:FSharp.Stats.ML.SurprisalAnalysis.SAResult">
<summary>
Summary type for the results of applying Surprisal Analysis to a dataset
</summary>
</member>
<member name="M:FSharp.Stats.ML.SurprisalAnalysis.compute(FSharp.Stats.Matrix{System.Double})">
<summary>
performs Surprisal Analysis on the input matrix A. For meaningfull results, A should be 
of the following form:
The rows contain measurements for a single unique entity,
corresponding to timepoints represented by the columns
</summary>
</member>
<member name="T:FSharp.Stats.ML.DistanceMetrics.Distance`1">
<summary>
 Signiture type for distance functions
</summary>
</member>
<member name="M:FSharp.Stats.ML.DistanceMetrics.wagnerFischerLazy(System.String,System.String)">
<summary>
 Levenshtein distance between
</summary>
</member>
<member name="M:FSharp.Stats.ML.DistanceMetrics.dissimilarity``3(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
<summary>
 &quot;Dissimilarity&quot; uses 1. - pearsons correlation coefficient 
</summary>
</member>
<member name="M:FSharp.Stats.ML.DistanceMetrics.cityblockNaN(System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Double})">
<summary>
 Cityblock distance of two coordinate float sequences
</summary>
</member>
<member name="M:FSharp.Stats.ML.DistanceMetrics.cityblock``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
<summary>
 Cityblock distance of two coordinate float sequences
</summary>
</member>
<member name="M:FSharp.Stats.ML.DistanceMetrics.euclideanNaNSquared(System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Double})">
<summary>
 Squared Euclidean distance of two coordinate float sequences (ignores nan)
</summary>
</member>
<member name="M:FSharp.Stats.ML.DistanceMetrics.euclideanNaN(System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Double})">
<summary>
 Euclidean distance of two coordinate float sequences (ignores nan)
</summary>
</member>
<member name="M:FSharp.Stats.ML.DistanceMetrics.euclidean``4(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
<summary>
 Euclidean distance of two coordinate sequences
</summary>
</member>
<member name="M:FSharp.Stats.ML.DistanceMetrics.Array.cityblockNaN(System.Double[],System.Double[])">
<summary>
 Cityblock distance of two coordinate float arrays (ignores nan)
</summary>
</member>
<member name="M:FSharp.Stats.ML.DistanceMetrics.Array.cityblock``2(``0[],``0[])">
<summary>
 Cityblock distance of two coordinate arrays
</summary>
</member>
<member name="M:FSharp.Stats.ML.DistanceMetrics.Array.euclideanNaNSquared(System.Double[],System.Double[])">
<summary>
 Squared Euclidean distance of two coordinate float arrays (ignores nan)
</summary>
</member>
<member name="M:FSharp.Stats.ML.DistanceMetrics.Array.euclideanNaN(System.Double[],System.Double[])">
<summary>
 Euclidean distance of two coordinate float arrays (ignores nan)
</summary>
</member>
<member name="M:FSharp.Stats.ML.DistanceMetrics.Array.euclidean``3(``0[],``0[])">
<summary>
 Euclidean distance of two coordinate arrays
</summary>
</member>
<member name="M:FSharp.Stats.ML.DistanceMetrics.Vector.cityblockNaN(FSharp.Stats.Vector{System.Double},FSharp.Stats.Vector{System.Double})">
<summary>
 Cityblock distance of two vectors
</summary>
</member>
<member name="M:FSharp.Stats.ML.DistanceMetrics.Vector.cityblock``2(FSharp.Stats.Vector{``0},FSharp.Stats.Vector{``0})">
<summary>
 Cityblock distance of two vectors
</summary>
</member>
<member name="M:FSharp.Stats.ML.DistanceMetrics.Vector.euclideanNaN(FSharp.Stats.Vector{System.Double},FSharp.Stats.Vector{System.Double})">
<summary>
 Euclidean distance between 2 vectors (ignores nan) 
</summary>
</member>
<member name="M:FSharp.Stats.ML.DistanceMetrics.Vector.euclideanSquared``3(FSharp.Stats.Vector{``0},FSharp.Stats.Vector{``0})">
<summary>
 Squared Euclidean distance between 2 vectors
</summary>
</member>
<member name="M:FSharp.Stats.ML.DistanceMetrics.Vector.euclidean``3(FSharp.Stats.Vector{``0},FSharp.Stats.Vector{``0})">
<summary>
 Euclidean distance between 2 vectors
</summary>
</member>
<member name="T:FSharp.Stats.ML.DistanceMetrics">
<summary>
Functions for computing distances of elements or sets
</summary>
</member>
<member name="T:FSharp.Stats.ML.Impute.MatrixBaseImputation`2">
<summary>
 Type definintion for a vector based imputation
 The imputed values are based on the given whole dataset
</summary>
</member>
<member name="T:FSharp.Stats.ML.Impute.VectorBaseImputation`1">
<summary>
 Type definintion for a vector based imputation.
 The imputed values are based only on the given array
</summary>
</member>
<member name="M:FSharp.Stats.ML.Impute.imputeBy``2(Microsoft.FSharp.Core.FSharpFunc{System.Collections.Generic.IEnumerable{``0[]},Microsoft.FSharp.Core.FSharpFunc{``0[],Microsoft.FSharp.Core.FSharpFunc{System.Int32,``0}}},Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},System.Collections.Generic.IEnumerable{``1})">
<summary>
 Imputes rows by matrix-based imputation
</summary>
</member>
<member name="M:FSharp.Stats.ML.Impute.imputeRowWiseBy``2(Microsoft.FSharp.Core.FSharpFunc{System.Collections.Generic.IEnumerable{``0},Microsoft.FSharp.Core.FSharpFunc{System.Int32,``0}},Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},System.Collections.Generic.IEnumerable{``1})">
<summary>
 Imputes row-wise by vector-based imputation
</summary>
</member>
<member name="M:FSharp.Stats.ML.Impute.imputeColWiseBy``2(Microsoft.FSharp.Core.FSharpFunc{System.Collections.Generic.IEnumerable{``0},Microsoft.FSharp.Core.FSharpFunc{System.Int32,``0}},Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},System.Collections.Generic.IEnumerable{``1})">
<summary>
 Imputes column-wise by vector-based imputation
</summary>
</member>
<member name="M:FSharp.Stats.ML.Impute.kNearestImpute(System.Int32,System.Collections.Generic.IEnumerable{System.Double[]},System.Double[],System.Int32)">
<summary>
 Imputation by k-nearest neighbour
</summary>
</member>
<member name="M:FSharp.Stats.ML.Impute.normal(System.Collections.Generic.IEnumerable{System.Double},System.Int32)">
<summary>
 Imputation by sampling from a gausian normal distribution based on the input vector
</summary>
</member>
<member name="M:FSharp.Stats.ML.Impute.rnd``1(System.Random,System.Collections.Generic.IEnumerable{``0},System.Int32)">
<summary>
 Imputation by random sampling from the input vector
</summary>
</member>
<member name="T:FSharp.Stats.ML.Impute">
<summary>
 Module for data imputation and missing value filtering
</summary>
</member>
<member name="T:FSharp.Stats.ML.Unsupervised.PCA.AdjustmentFactory">
<summary>
 AdjustmentFactorygiven,given a dataset, 
</summary>
</member>
<member name="T:FSharp.Stats.ML.Unsupervised.PCA.Component">
<summary>
 Represents a principle component 
</summary>
</member>
<member name="M:FSharp.Stats.ML.Unsupervised.PCA.zipScree(FSharp.Stats.ML.Unsupervised.PCA.Component[])">
<summary>
 Returns xy-coordinates for scree plot in a tuple (component number vs. EigenValue)    
 Scree plot: represents the ability of PCs to explain de variation in data
</summary>
</member>
<member name="M:FSharp.Stats.ML.Unsupervised.PCA.revert(Microsoft.FSharp.Core.FSharpFunc{FSharp.Stats.ML.Unsupervised.PCA.AdjustmentDirection,Microsoft.FSharp.Core.FSharpFunc{FSharp.Stats.Matrix{System.Double},FSharp.Stats.Matrix{System.Double}}},FSharp.Stats.ML.Unsupervised.PCA.Component[],FSharp.Stats.Matrix{System.Double})">
<summary>
   Reverts a set of projected data into it&apos;s original form. Complete reverse
   transformation is only possible if all components are present, and, if the
   data has been standardized, the original standard deviation and means of
   the original matrix are known.
</summary>
</member>
<member name="M:FSharp.Stats.ML.Unsupervised.PCA.transform(Microsoft.FSharp.Core.FSharpFunc{FSharp.Stats.ML.Unsupervised.PCA.AdjustmentDirection,Microsoft.FSharp.Core.FSharpFunc{FSharp.Stats.Matrix{System.Double},FSharp.Stats.Matrix{System.Double}}},FSharp.Stats.ML.Unsupervised.PCA.Component[],FSharp.Stats.Matrix{System.Double})">
<summary>
 Projects a given matrix into principal component space (projections or factor scores)
</summary>
</member>
<member name="M:FSharp.Stats.ML.Unsupervised.PCA.getCommunality(FSharp.Stats.ML.Unsupervised.PCA.Component[])">
<summary>
 Returns communality
</summary>
</member>
<member name="M:FSharp.Stats.ML.Unsupervised.PCA.getFeatureMatrixOfComponents(FSharp.Stats.ML.Unsupervised.PCA.Component[])">
<summary>
 Returns feature matrix (eigenvector matrix) from components
</summary>
</member>
<member name="M:FSharp.Stats.ML.Unsupervised.PCA.compute(Microsoft.FSharp.Core.FSharpFunc{FSharp.Stats.ML.Unsupervised.PCA.AdjustmentDirection,Microsoft.FSharp.Core.FSharpFunc{FSharp.Stats.Matrix{System.Double},FSharp.Stats.Matrix{System.Double}}},FSharp.Stats.Matrix{System.Double})">
<summary>
 Computes a principal componant analysis
</summary>
</member>
<member name="M:FSharp.Stats.ML.Unsupervised.PCA.computeOfMatrix(FSharp.Stats.Matrix{System.Double})">
<summary>
 Computes a principal componant analysis of a given covariance matrix
 !Attention: Matrix needs to be centered before
</summary>
</member>
<member name="M:FSharp.Stats.ML.Unsupervised.PCA.createComponentsOf(FSharp.Stats.Matrix{System.Double},System.Collections.Generic.IEnumerable{System.Double})">
<summary>
 Creates the principle components of eigenVectors and eigenValues
</summary>
</member>
<member name="M:FSharp.Stats.ML.Unsupervised.PCA.createComponent(System.Double[],System.Double,System.Double[],System.Double,System.Double,System.Int32)">
<summary>
 Creates a principle component type
</summary>
</member>
<member name="M:FSharp.Stats.ML.Unsupervised.PCA.toAdjustCorrelation(FSharp.Stats.Matrix{System.Double})">
<summary>
 Returns an AdjustmentFactory which centers and standardize the data
</summary>
</member>
<member name="M:FSharp.Stats.ML.Unsupervised.PCA.toAdjustStandardize(FSharp.Stats.Matrix{System.Double})">
<summary>
 Returns an AdjustmentFactory which centers and standardize the data
</summary>
</member>
<member name="M:FSharp.Stats.ML.Unsupervised.PCA.toAdjustCovariance(FSharp.Stats.Matrix{System.Double})">
<summary>
 Returns an AdjustmentFactory as covariance matrix
</summary>
</member>
<member name="M:FSharp.Stats.ML.Unsupervised.PCA.toAdjustCenter(FSharp.Stats.Matrix{System.Double})">
<summary>
 Returns an AdjustmentFactory which centers the data
</summary>
</member>
<member name="T:FSharp.Stats.ML.Unsupervised.PCA">
<summary>
 Principle component analysis 
</summary>
</member>
<member name="P:FSharp.Stats.ML.Unsupervised.IterativeClustering.KClusteringResult`1.DistanceMetric">
<summary>
 Used distance metric
</summary>
</member>
<member name="P:FSharp.Stats.ML.Unsupervised.IterativeClustering.KClusteringResult`1.ClosestDistances">
<summary>
 Indices and Distances to closest centroid
</summary>
</member>
<member name="P:FSharp.Stats.ML.Unsupervised.IterativeClustering.KClusteringResult`1.Classifier">
<summary>
 Classifier function returns cluster index and data point
</summary>
</member>
<member name="P:FSharp.Stats.ML.Unsupervised.IterativeClustering.KClusteringResult`1.Centroids">
<summary>
 Centroids with index and data
</summary>
</member>
<member name="T:FSharp.Stats.ML.Unsupervised.IterativeClustering.KClusteringResult`1">
<summary>
 Result of a kmeans clustering
</summary>
</member>
<member name="M:FSharp.Stats.ML.Unsupervised.IterativeClustering.DispersionOfClusterResult``1(FSharp.Stats.ML.Unsupervised.IterativeClustering.KClusteringResult{``0})">
<summary>
 Calculates the average squared distance from the data points
 to the cluster centroid (also refered to as error)
</summary>
</member>
<member name="M:FSharp.Stats.ML.Unsupervised.IterativeClustering.Dispersion``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,System.Double}},Microsoft.FSharp.Collections.FSharpList{``0},System.Collections.Generic.IEnumerable{``0})">
<summary>
 Calculates the average squared distance from the data points
 to the cluster centroid (also refered to as error)
</summary>
</member>
<member name="M:FSharp.Stats.ML.Unsupervised.IterativeClustering.nearestDistance``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,System.Double}},``0[],``0)">
<summary>
 Calculates the distance from the data point to the centroid 
</summary>
</member>
<member name="M:FSharp.Stats.ML.Unsupervised.IterativeClustering.createKClusteringResult``1(System.Tuple{System.Int32,``0}[],Microsoft.FSharp.Core.FSharpFunc{``0,System.Tuple{System.Int32,``0}},System.Tuple{System.Int32,System.Double}[],Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,System.Double}})">
<summary>
 Creates a k-clustering  result
</summary>
</member>
<member name="T:FSharp.Stats.ML.Unsupervised.HierarchicalClustering.DistanceCaching`1">
<summary>
 Class for chaching already calculated distances to speed up cluster build
</summary>
</member>
<member name="M:FSharp.Stats.ML.Unsupervised.HierarchicalClustering.printHClust``1(FSharp.Stats.ML.Unsupervised.HierarchicalClustering.Cluster{``0})">
<summary>
 Converts clusters into string seq
</summary>
</member>
<member name="M:FSharp.Stats.ML.Unsupervised.HierarchicalClustering.cutHClust``1(System.Int32,FSharp.Stats.ML.Unsupervised.HierarchicalClustering.Cluster{``0})">
<summary>
 Cuts a tree, as resulting from hclust, into several groups by specifying the desired number(s).
 If the desired number is odd the function cut the cluster with maximal distance
</summary>
</member>
<member name="M:FSharp.Stats.ML.Unsupervised.HierarchicalClustering.flattenHClust``1(FSharp.Stats.ML.Unsupervised.HierarchicalClustering.Cluster{``0})">
<summary>
 Returns a flatten list containing Leafs
</summary>
</member>
<member name="M:FSharp.Stats.ML.Unsupervised.HierarchicalClustering.getClusterMemberLabels``1(FSharp.Stats.ML.Unsupervised.HierarchicalClustering.Cluster{``0})">
<summary>
 Returns 
</summary>
</member>
<member name="M:FSharp.Stats.ML.Unsupervised.HierarchicalClustering.generate``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,System.Double}},Microsoft.FSharp.Core.FSharpFunc{System.Tuple{System.Int32,System.Int32,System.Int32},Microsoft.FSharp.Core.FSharpFunc{System.Double,Microsoft.FSharp.Core.FSharpFunc{System.Double,Microsoft.FSharp.Core.FSharpFunc{System.Double,System.Double}}}},System.Collections.Generic.IEnumerable{``0})">
<summary>
 Builds a hierarchy of clusters of data containing cluster labels
</summary>
</member>
<member name="T:FSharp.Stats.ML.Unsupervised.HierarchicalClustering.Linker.LancWilliamsLinker">
<summary>
 Signiture type for Lance and Williams Linker functions
 D(A u B,C) = alpa1 d(A,C) +  alpa2 d(B,C) + beta d(A,B) + gamma |d(A,C) - d(BC))|
</summary>
</member>
<member name="M:FSharp.Stats.ML.Unsupervised.HierarchicalClustering.Linker.wardLwLinker(System.Int32,System.Int32,System.Int32,System.Double,System.Double,System.Double)">
<summary>
 Ward linkage criterion (UPGMA)
 Calculates the 
 d(A u B, C)
</summary>
</member>
<member name="M:FSharp.Stats.ML.Unsupervised.HierarchicalClustering.Linker.centroidLwLinker(System.Int32,System.Int32,System.Int32,System.Double,System.Double,System.Double)">
<summary>
 Centroid linkage criterion (UPGMA)
 Calculates the 
 d(A u B, C)
</summary>
</member>
<member name="M:FSharp.Stats.ML.Unsupervised.HierarchicalClustering.Linker.upgmaLwLinker(System.Int32,System.Int32,System.Int32,System.Double,System.Double,System.Double)">
<summary>
 Unweighted Group Average linkage criterion (UPGMA)
 Calculates the 
 d(A u B, C)
</summary>
</member>
<member name="M:FSharp.Stats.ML.Unsupervised.HierarchicalClustering.Linker.weightedGroupAverageLwLinker(System.Int32,System.Int32,System.Int32,System.Double,System.Double,System.Double)">
<summary>
 Weighted Group Average linkage criterion
 Calculates the 
 d(A u B, C)
</summary>
</member>
<member name="M:FSharp.Stats.ML.Unsupervised.HierarchicalClustering.Linker.medianLwLinker(System.Int32,System.Int32,System.Int32,System.Double,System.Double,System.Double)">
<summary>
 Median linkage criterion
 Calculates the 
 d(A u B, C)
</summary>
</member>
<member name="M:FSharp.Stats.ML.Unsupervised.HierarchicalClustering.Linker.completeLwLinker(System.Int32,System.Int32,System.Int32,System.Double,System.Double,System.Double)">
<summary>
 Complete linkage criterion
 Calculates the 
 d(A u B, C)
</summary>
</member>
<member name="M:FSharp.Stats.ML.Unsupervised.HierarchicalClustering.Linker.singleLwLinker(System.Int32,System.Int32,System.Int32,System.Double,System.Double,System.Double)">
<summary>
 Single linkage criterion
 Calculates the minimal distance between all elements of a cluster
 d(A u B, C)
</summary>
</member>
<member name="T:FSharp.Stats.ML.Unsupervised.HierarchicalClustering.Linker">
<summary>
 The linkage criterion determines the distance between sets of observations as a function of the pairwise distances between observations
</summary>
</member>
<member name="T:FSharp.Stats.ML.Unsupervised.HierarchicalClustering">
<summary>
 Agglomerative hierarchical clustering
</summary>
</member>
</members>
</doc>
